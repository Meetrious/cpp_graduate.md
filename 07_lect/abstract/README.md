# [Лекция 7: Перегрузка операторов (продолжение)](https://youtu.be/lHxf3_uHbKg)
Смотивируем оператор "круглые скобочки" бенчмарком сортировки из стандарта.

Сортирующая функция из стандарта [`std::sort`](https://en.cppreference.com/w/cpp/algorithm/sort) лежит в `<algorithm>`. И интересующая нас сигнатура для неё выглядит, например, так:
```c++
template< class RandomIt, class Compare >
void sort( RandomIt first, RandomIt last, Compare comp );
```
- `RandomIt first` - это обобщенный указатель (в частности `int*`) на первый элемент контейнера (массива).
- `RandomIt last` - это обобщенный указатель (в частности `int*`) на последний элемент контейнера (массива). 
- `Compare comp` - это аргумент под фукнция-подобный объект (в частности указатель на функцию), от которого требуется умение принимать два однородных аргумента (в частности`(int, int)`) и возвращать в `bool` приводимое значение. Таким объектом в частности может быть компаратор для `int`.

Если под объектом `comp`, окажется предикат, определяющий линейный порядок на множестве объектов под указателями `RandomIt`, функция `std::sort` корректно произведёт сортировку (вроде бы на алгоритме *quick sort*).

В Си `std::sort` написан на `void*`-указателях, и в качестве компаратора мы могли передать третьим аргументом только указатель на соответствующую функцию.

Проведём [бенчмарк производительности sort на Си](https://github.com/tilir/cpp-graduate/blob/master/05-opers/qsortbench.cc).

        да, код по ссылке написан на C++, 
        но в нём на самом деле нет ничего такого,
        чего нельзя было бы написать на Си.
```bash
$ g++ -O2 qsortbench.cc  # -O2 флаг предпримет оптимизации при сборке
$ ./a.out 30000000  # запустим скомпилированную программу для сортировки
# на массиве из 30 миллионов случайно сгенерированных целых чиселок.
```
в ответ увидим следуюшее:

<img src="imgs/qsort-noinline.png"> <br/>
Кол-во *elapsed*-секунд описывает, сколько в точности понадобилось времени на сортировку такого массива с помощью `std::sort`. Моему процессору понадобилось 2.78 секунд. В связи с произвольностью генерации чисел при повторном запуске может получиться другое, но близкое время. На другой системе - другое и, возможно, не близкое.

В [`qsortbench.cc`](https://github.com/tilir/cpp-graduate/blob/master/05-opers/qsortbench.cc) самое главное, на что надо обратить внимание - это 19 и 44 строчки.

```c++
...
int greater(const int &lhs, const int &rhs) { return lhs > rhs; }  // <<-- сюда
int main (int argc, char **argv) {
...
	std::sort(narr, narr + nelts, greater);  // <<-- и сюда
}
```
В `std::sort` утекает функция `greater`. И происходит это, на самом деле, по указателю на функцию.

Теперь перейдём в *C++*, где у нас есть операторы приведения, алиасы, и попробуем ещё один вариант. На этот раз будем передавать не фукнцию, а объект, который ведёт себя, как функция. Переходим [сюда](https://github.com/tilir/cpp-graduate/blob/master/05-opers/qsortbench-cast.cc).

В самом начале видим вот такую структуру:
```c++
struct myless {
  static bool less(const int &lhs, const int &rhs) { return lhs > rhs; }
  using lessptr_t = bool (*)(const int &lhs, const int &rhs);
  operator lessptr_t() const { return less; }
};
```
> **Вопрос**: Что в ней вообще происходит, и что будет, если мы передадим объект этой структуры в третий аргумент `std::sort`-функции?
>> Передав объект третьим аргументом
>> ```c++
>> std::sort(narr, narr + nelts, myless{});
>> ```
>> компилятор попытается проинтерпретировать его, как функцию. В связи с этим он будет искать возможность приведения его к функция-подобному объекту. Наткнётся на `operator lessptr_t()`, где `lessptr_t` - это алиас для типа указателя на функцию с сигнатурой `bool (*)(const int &lhs, const int &rhs)`. Такая сигнатура более чем удовлетворяет требованию "уметь принимать `(int, int)` и возвращать `bool`", а значит этот оператор неявно вызовется.
>>
>> После приведения объект станет вот этим вот указателем `bool (*)(const int &lhs, const int &rhs)`, которому, согласно определению `operator lessptr_t()`, будет присвоен статический метод `myless::less`.
>>
>> И только после всего этого точка исполнения зайдёт внутрь `std::sort`.

Жуткий для осознания способ задания функция-подобного объекта, но вполне себе рабочий для наших целей. В этом случае бенчмарк выдаст следующее время:

<img src="imgs/qsort-inline-cast.png" height = "" width = ""> <br/>

Почти на секунду шустрее заработал. А всё потому, что "*в метод `std::sort` утёк вполне конкретный тип третьего аргумента, и в связи с этим вызов функции `myless::less` заинлайнился*". 

## [Перегрузка `operator()`](https://youtu.be/lHxf3_uHbKg?t=500)

Так вот, чтобы при создании функция-подобного объекта из пользовательского типа не замарачиваться с многоходовками из неявных приведений и вспомогательных алиасов, достаточно перегрузить `operator()`. 

> <div style="text-align: center"><i>Тип, в котором определён <code>operator()</code>, в народе кличут <b>функтором</b>.</i></div> 

 И в случае передачи функтора третьим аргументом в `std::sort` вызов компаратора, кой и является перегруженный `operator()`, аналогично заинлайнится. Код вот [здеся вот](https://github.com/tilir/cpp-graduate/blob/master/05-opers/qsortbench-op.cc).

В нём `myless` - это функтор. 

```c++
struct myless {
  bool operator()
  (const int &lhs, const int &rhs) const 
  { return lhs > rhs; }
};
```
Вызов аналогичен.

```c++
std::sort(narr, narr + nelts, myless{});
```
Результат по времени тот же, что и в случае выше.

В связи со сказанным, спецсемантика перегрузки `operator()` может звучать примерно так:
> <div style="text-align: center"><b>Если во мне перегружен <code>operator()</code>, то в нужном контексте я способен неявно приводиться к типу функции с сигнатурой той самой перегрузки.</b></div>
</br>

Другой способ заинлайнить вызов компаратора, это написать для него анонимную функцию (лямбда-выражение) на месте передачи третьего аргумента в `std::sort`. Этот приём [здесь закомментирован](https://github.com/tilir/cpp-graduate/blob/master/05-opers/qsortbench-op.cc), в [лекции тизерится](https://youtu.be/lHxf3_uHbKg?t=738) всеми правдами/неправдами, а я, пожалуй, его пропущу и пойду дальше.

Таким образом использование функторов по сравнению с обычными указателями на функцию может обеспечить нам кучу перфоманса. `operator()` замотивирован.

---

Теперь замотивируем часть, где перегрузка операторов помогает нам с удобными абстракциями.