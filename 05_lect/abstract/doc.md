# [Лекция 5 (RAII и перемещение)](https://youtu.be/_mLDaU4wSOo)

Эта лекция посвящена классам, которые владеют своими ресурсами; так называемым *RAII-классам*. А так же мы начнём говорить о семантике перемещения.

## [Владение ресурсом и извороты в Си в попытках ](https://youtu.be/_mLDaU4wSOo?t=113)

> **Вопрос**: Что значит владеть ресурсом?

Вопрос философский. И может показаться, что ответ на него мол: "*владеть = иметь к ним доступ, подступаться к методам для работы с ним*". Однако ж чтобы ресурс был, его нужно создать, и потому

>> - **владеть** ресурсом = **уметь его выделять, освобождать и, возможно, предоставлять безопасный доступ**.

> **Вопрос**: какие существуют ценные ресурсы в контексте инструментов программирования?
>> - файловые хэндлы
>> - сетевые соединения
>> - память

Последний является наиболее важным и наиболее простым.

Владение ресурсом - это то, за чем мы должны следить, ведь если этого не делать, то этот ресурс может утечь, как например здесь

```c++
int main() { ...
  S *p = new S;
  foo(p);  // ресурс утёк в foo, и может быть там непредвиденно освобождён
  delete p;  // возможно двойное удаление
}
```
И если освобождение ресурса не локализовано в ответственности некоторого механизма этого самого ресурса (например засчёт конструктора деструктора), в языке *C* нам приходится этим освобождением заниматься непосредственно по месту событий. И, к сожалению, в языке *C* этим заниматься крайне неудобно.

Рассмотрим популярный пример кода на *C*, который приходится писать, если ответственность за динамическую память вешается на реализацию ф-ции.
```c
int foo(int n) {
  struct S *p = malloc (sizeof(struct S)); 
  // .... some code ....
  if (condition) {
    free(p);
    return FAILURE;
  }  
  // .... some code ....

  return SUCCESS;
}
```
Здесь две точки освобождения. Хотелось бы иметь одну.
И частично вопреки правилам структурного программирования это можно осуществить, используя оператор `goto`.

```c
int foo(int n) {
  struct S *p = malloc (sizeof(struct S));
  int result = SUCCESS; 
  // .... some code ....
  if (condition) {
    result = FAILURE;
    goto cleanup;
  }
  // .... some code ....
  cleanup:
  free(p);
  return result;
}
```
Но `goto` - это, как бы, плохо. Тем не менее, у нас есть [Linux kerner coding style](https://www.kernel.org/doc/html/v4.10/process/coding-style.html), где в пункте 7, именуемом [centralized exiting of functions](https://www.kernel.org/doc/html/v4.10/process/coding-style.html#centralized-exiting-of-functions), умные люди, которые проектировали *Linux kernel* на *C*, советуют писать именно так.

Ну и давайте раз и навсегда разберёмся, **почему `goto` - это плохо**.
> - Эдгар Дейкстра в 1968 году опубликовал статью [Go To Statement Considered Harmful](https://homepages.cwi.nl/~storm/teaching/reader/Dijkstra68.pdf). И речь шла о том, что злоупотребление `goto` плохо не для компилятора, а именно для программиста. Анализировать код, в котором использование `goto`-оператора - обычное дело, очень сложно. **Почему сложно?**
> 
>> Если структура нашей программы суть - вложенные блоки циклов и условных конструкций, то в ней нет непредсказуемых нелокальных выходных дуг. Мы точно можем быть уверены, что выходы производятся из шапок `for`, `if`, по достижению `return`; вся блочная структура программы представляет из себя вложенное дерево из блоков.
`goto` делает из дерева произвольный граф, цепочку исполнения которого анализировать намного труднее.

В своё время, означенная статья Дейкстры произвела на всех такое впечатление, что люди начали `goto` стесняться. А когда люди стесняются `goto`, люди `goto` начинают маскировать. В связи с этим появились такие ключевые слова, как `break`, `continue`, `switch-case`. Вариант реализации кода выше от стеснительного программиста выглядит, например, так:

```c
int foo(int n) {
  struct S *p = malloc (sizeof(struct S));
  int result = SUCCESS; 
  do {
    // .... some code ....
    if (condition) {
      result = FAILURE;
      break;  // что вы?!, какой goto? неее 
    }
    // .... some code ....
  } while(0);
  free(p);
  return result;
}
```
Цикл из одной итерации, из которой делается условный и вполне законный `break`. Выглядит по-ублюдски, но зато социально-приемлемо.

Другая проблема с `goto`, которая стала заметна в 90х, состоит в следующем.
Если у объектов есть состояние, и инициализация этого состояния происходит через вызов конструктора, то дуга `goto` может пересекать точки начала жизни объектов и точки их смерти по отдельности. Например вот функция со `switch-case`:

```c++
int foo(int cond) {
  switch(cond) {
    case 0: X x;
    case 1: return x.smth;
  }
}
```
> "***Дуги control flow не должны пересекать точки создания объектов и их уничтожения.***". Ведь если метка для `goto` находится внутри блока после начала *scope* некоторой переменной, но до его окончания, то точка исполнения, пройдя по этой метке, рискует наткнуться на диррективу в связи с объектом, который не был даже *default*-сконструирован. Обращение к объекту, который ещё не родился - это UB.
> 
> И слава Богу, в *C++* это ошибка компиляции, причём формулируется она ожидаемым образом:
> 
> <img src="imgs/jump-across-ctor.png"> <br/>

 Поэтому если в коде на *C* довольно легко прыгнуть из тела одного цикла-`for` внутрь тела другого цикла-`for` выше, то на *C++* это сложно, ведь в последнем появляется инициализация объектов вызовом конструктора.

 В связи с этим безопасно в коде на *C++* не забывать о явных блоках при описании `case`-ов
 ```c++
int foo(int cond) {
  switch(cond) {
    case 0: {X x}; 
    case 1: return x.smth;  // очевидная ошибка; x не виден
  }
}
```

Чтобы не заниматься всем этим контролем над освобождением ресурсов в *C++*, выше мы уже упомянули: надо использовать **механизмы деструкторов**.

---
## [RAII (Resource acquisition is initialisation)](https://youtu.be/_mLDaU4wSOo?t=627)

> ***RAII-классы*** - *это классы, которые владеют своими ресурсами*.

Владеют в том смысле, что и обсуждалось в разделе выше.
Вспомним самый первый пример.
```c++
int main() { ...
  S *p = new S;
  foo(p);
  delete p;
}
```
В этом примере мы хотели бы защитить наш указатель `p` от преждевременного освобождения динамической памяти по нему, а так же, чтобы это происходило в некотором смысле автоматически:

- выделение происходило по объявлению (возможно в некоторой степени конкретезированному);
- освобождение происходило по достижению `return`;

Короче, чтобы выше означенный шаблон реализации `foo` на *C++* выглядел чище и проще. Вот так, например:
```c++
template <typename S> int foo (int n) {
  ScopedPointer<S> p{new S(n)}; // ownership passed
  // .... some code ....
  if (condition) return FAILURE; // dtor called: delete
  // .... some code ....
  return SUCCESS; // dtor called: delete
}
```
Теперь реализация `foo` не в ответе за освобождение памяти по указателю `p`. Эта ответсвтенность переложена на реализацию шаблонного класса `ScopedPointer`.

> **Вопрос**: Как может выглядеть реализация этого `ScopedPointer`?
>> - например вот так
>> ```c++
>> template <typename T> class ScopedPointer {
>>   T *ptr_;
>>    public:
>>      ScopedPointer(T *ptr = nullptr) : ptr_(ptr) {}
>>      ~ScopedPointer() { delete ptr_; }
>> };
>>```
>> Более того, ни `foo`, ни какая другая ф-ция, на стеке которой будут объявляться указатели `ScopedPointer<type>`, не смогут легально перехватить ответственность за **выделенный** на этот указатель **ресурс**, потому что указатель с этим адресом заинкапсулирован в `private` части реализации `ScopedPointer`.

> Инвариант класса `ScopedPointer`:
> <div style="text-align: center"><i><b>Никто кроме меня не имеет доступа к указателю, который я внутри себя храню.</i></b></div>
В связи с этим класс `ScopedPointer` ещё можно называть *<u>RAII-обёрткой вокруг сырых указателей</u>*

С учётом сказанного в конце предыдущей лекции можно уследить одно замечательное качество этого конструктора описанной *RAII*-обертки:

> Шаблонность конструктора `ScopedPointer(T *ptr = nullptr)` относительно параметра `T` допускает неявное преобразование любого сырого указателя на **любой тип** в объект `ScopedPointer`, параметризованный **этим самым любым типом**.

И замечательно это потому, что `ScopedPointer` гарантирует обратную совместимость с любым *legacy*-кодом, который оперировал сырыми указателями. Т.е. например в целях безопасности, мы можем тупо заменить все вхождения аргументов, передаваемых по указателю на аргументы-значения типа `ScopedPointer` в *legacy*-коде, убрать из него ненужные `free/delete`, и его логика сохранится.

> Вопрос: ага, сохранится, лол. 
> - А разве `ScopedPointer` поддерживает оператор `->` нужным нам образом?!
> - Разве копирование при передаче `ScopedPointer` в ф-ию по значению - это хорошая идея в текущем состоянии реализации?!

Нет, и нет. А потому надо бы корректно описать реализацию всех этих базовых инструментов.