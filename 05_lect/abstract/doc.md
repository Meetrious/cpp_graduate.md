# [Лекция 5 (RAII и перемещение)](https://youtu.be/_mLDaU4wSOo)

Эта лекция посвящена классам, которые владеют своими ресурсами, и семантике перемещения.

## [Владение ресурсом](https://youtu.be/_mLDaU4wSOo?t=113)

> **Вопрос**: Что значит владеть ресурсом?

Вопрос философский. И может показаться, что ответ на него мол: "*владеть = иметь к ним доступ, подступаться к методам работы с ним*". Однако ж чтобы ресурс был, его нужно создать, и потому

>> - **владеть** ресурсом = **уметь его выделять, освобождать и, возможно, предоставлять безопасный доступ**.

> **Вопрос**: какие существуют ценные ресурсы в контексте инструментов программирования?
>> - файловые хэндлы
>> - сетевые соединения
>> - память

Последний является наиболее важным и наиболее простым.

Владение ресурсом - это то, за чем мы должны следить, ведь если этого не делать, то этот ресурс может утечь, как например здесь

```c++
int main() { ...
  S *p = new S;
  foo(p);  // ресурс утёк в foo, и может быть там непредвиденно освобождён
  delete p;  // возможно двойное удаление
}
```
И если освобождение ресурса не локализовано в ответственности некоторого механизма (например деструктора), в языке *C* нам приходится этим освобождением заниматься непосредственно по месту событий. И, к сожалению, в языке *C* этим заниматься крайне неудобно.

Рассмотрим популярный пример кода на *C*, который приходится писать, если ответственность за динамическую память вешается на реализацию ф-ции.
```c
int foo(int n) {
  struct S *p = malloc (sizeof(struct S)); 
  // .... some code ....
  if (condition) {
    free(p);
    return FAILURE;
  }  
  // .... some code ....

  return SUCCESS;
}
```
Здесь две точки освобождения. Хотелось бы иметь одну.
И вопреки правилам структурного программирования это можно осуществить, используя оператор `goto`.

```c
int foo(int n) {
  struct S *p = malloc (sizeof(struct S));
  int result = SUCCESS; 
  // .... some code ....
  if (condition) {
    result = FAILURE;
    goto cleanup;
  }
  // .... some code ....
  cleanup:
  free(p);
  return result;
}
```
Но `goto` - это, как бы, плохо. Тем не менее, у нас есть [Linux kerner coding style](https://www.kernel.org/doc/html/v4.10/process/coding-style.html), где в пункте 7, именуемом [centralized exiting of functions](https://www.kernel.org/doc/html/v4.10/process/coding-style.html#centralized-exiting-of-functions), умные люди, которые проектировали *Linux kernel* на *C*, советуют писать именно так.

Ну и давайте раз и навсегда разберёмся, **почему `goto` - это плохо**.
> - Эдгар Дейкстра в 1968 году опубликовал статью [Go To Statement Considered Harmful](https://homepages.cwi.nl/~storm/teaching/reader/Dijkstra68.pdf). И речь шла о том, что злоупотребление `goto` плохо не для компилятора, а именно для программиста. Анализировать код, в котором использование `goto`-оператора - обычное дело, очень сложно. **Почему сложно?**
> 
>> Если структура нашей программы суть - вложенные блоки циклов и условных конструкций, то в ней нет непредсказуемых нелокальных выходных дуг. Мы точно можем быть уверены, что выходы производятся из шапок `for`, `if`, по достижению `return`; вся блочная структура программы представляет из себя вложенное дерево из блоков.
`goto` делает из дерева произвольный граф, цепочку исполнения которого анализировать намного труднее.

В своё время, означенная статья Дейксты произвела на всех такое впечатление, что люди начали `goto` стесняться. А когда люди стесняются `goto`, люди `goto` начинают маскировать. В связи с этим появились такие ключевые слова, как `break`, `continue`, `switch-case`. И один из вариантов, который бы стеснительный программист использовал при описании кода выше, выглядит, например, так:

```c
int foo(int n) {
  struct S *p = malloc (sizeof(struct S));
  int result = SUCCESS; 
  do {
    // .... some code ....
    if (condition) {
      result = FAILURE;
      break;  // что вы?!, какой goto? неее 
    }
    // .... some code ....
  } while(0);
  free(p);
  return result;
}
```
Цикл из одной итерации, из которой делается условный и вполне законный `break`. Выглядит по-ублюдски, но зато социально-приемлемо.

Другая проблема с `goto`, которая стала заметна в 90х, состоит в следующем.
Если у объектов есть состояние, и инициализация этого состояния происходит через вызов конструктора, то дуга `goto` может пересекать точки начала жизни объектов и точки их смерти по отдельности. Например вот функция со `switch-case`:

```c++
int foo(int cond) {
  switch(cond) {
    case 0: X x;
    case 1: return x.smth;
  }
}
```
> "***Дуги control flow не должны пересекать точки создания объектов и их уничтожения.***". 
> 
> И потому это ошибка компиляции.
> 
> <img src="imgs/jump-across-ctor.png"> <br/>

 Поэтому если в коде на *C* довольно легко прыгнуть из тела одного цикла-`for` внутрь тела другого цикла-`for` выше, то на *C++* это сложно, ведь в последнем появляется инициализация объектов вызовом конструктора.

 В связи с этим безопасно в коде на *C++* не забывать о явных блоках при описании `case`-ов
 ```c++
int foo(int cond) {
  switch(cond) {
    case 0: {X x}; 
    case 1: return x.smth;  // очевидная ошибка; x не виден
  }
}
```

Чтобы не заниматься всем этим контролем над освобождением ресурсов в *C++*, выше мы уже упомянуто: надо использовать **механизмы деструкторов**.

---
## [RAII (Resource acqucision is initialisation)](https://youtu.be/_mLDaU4wSOo?t=627)