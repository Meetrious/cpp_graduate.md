# [Лекция 6: Проектирование матриц (продолжение)](https://youtu.be/LDoCQzSd3xo)
На примере задач, которое оно ставит, очень удобно рассмотреть некоторые языковые механизмы.

Итак, проектирование.

## [***Матричные конструкторы***](https://youtu.be/LDoCQzSd3xo?t=54)

Как конструировать? Ну, первая идея - написать такой контсруктор, который ест число строк, столбцов и значениЕ, которЫМ надо матрицу заполнить.

```c++
template<typename T> class Matrix {
  // некое представление (т.е. указатель, куда будет выделяться память)
 public:
  /* конструктор для создания матрицы, 
   * заполненной конкретным значением, если конкретное указано,
   * или значением по умолчанию, иначе. */
  Matrix(int cols, int rows, T val = T{});

  /* конструктор для создания матрицы,
   * заполненой данными, расположенными
   * между итераторами start,fin (обобщенными указателями)
   * предполагая, что (fin - start) == (cols * rows) |-> true */
  template <typename It>
  Matrix(int cols, int rows, It start, It fin);
   ...
};
```
Про итераторы мы поговорим позже, а пока будем мыслить их, как к указатели, к которым можно применить `++` и они сдвигаются на следующее значение внутри некоторой коллекции. 

С матрицами, порой, хочется написать очень много конструкторов. Например
- тот, что будет создавать диагональную матрицу по заданному значению(ям)
- тот, что будет создавать верхне-треугольную матрицу
- ...

Можно, например, создать тегирующий `enum` тип внутри нашего класса, насоздавать там наименований, которые тегируют желаемый вид матрицы. Потом передавать тег в конструктор, который в свою очередь и будет создавать соответствующую матрицу. К сожалению это выглядит криво.

В таких случаях изящнее будет использовать в качестве конструкторов **статические функции класса**.

---

### [**`Static` и `friend` аннотированные методы**](https://youtu.be/LDoCQzSd3xo?t=295)
**Методы-члены класса** - это функции, которые имеют неявный аргумент `this`- указатель на объект, от которого и вызывается этот метод.
<u>Внутри реализации метода-члена класса мы имеем полный доступ к внутреннему состоянию любого объекта (достижимого внутри тела реализации метода) этого класса (т.е. в том числе к его приватным полям)</u>. Это мы знаем.

В дальнейшем будем говорить просто: "доступ к внутреннему состоянию класса", подразумевая то, что описано выше.

**Статические методы класса** - это функции, аннотированные `static`. Они вызываются БЕЗ неявного аргумента `this`, и для них `class`, в котором они находятся - это всё равно что `namespace` (причём их можно вызывать и от объектов класса, и через `MyNamespace::st_func(...)`). При этом, <u>внутри их реализации мы имеем полный доступ к внутреннему состоянию класса</u>.

И есть ещё **дружественные методы класса**. Аннотация `friend` на метод, объявленный внутри класса, говорит, что если где-то снаружи есть функция с такой же сигнатурой, то <u>внутри её реализации программист будет иметь полный доступ к внутреннему состоянию класса</u>, в котором эта ф-ция аннотирована `friend`.

И, как можно догадаться, последнее очень опасно.

```c++
class S {
  int x = 0;
 public:
  int get_x() const { return x; }  // метод-член
  static int s_get_x(const S *s) { return s->x; }  // статический метод
  friend int f_get_x(const S *s);  // дружественный метод
};

int f_get_x(const S *s) { return s->x; }
```
Удобна табличка в виде нижне-треугольной матрицы:
|   | методы-члены | статические</br> функции | друзья |
| - | - | - | - |
| получает неявный аргумент</br>`this` указатель | да | нет | нет |
| находится в</br> пространстве имен</br> класса | да | да | нет |
| имеет доступ к</br> закрытому состоянию</br> класса | да | да | да |

Класс умеет дружить не только с функциями, но и с целыми классами. Более того не исключена дружба с целыми шаблонами. Достаточно просто объявить соответствующую сущноть в теле и аннотировать её `friend`.
> **Вопрос**: Почему `friend` в *C++* - это плохо?
>> - Когда мы дойдём до шаблонов, мы об этом подробнее поговорим. Но сейчас it's safe to say: "<u>в общем случае в *C++* иметь друзей - это ошибка</u>".
>>
>> Статические методы класса определяет, или хотя бы объявляет, программист, который проектирует этот класс. Они - часть интерфейса класса, пространства имён и исходной задумки проектировщика класса, который скорее всего заботится о безопасности использования своего инструмента. В контексте этих неявных договорных отношений проектировщика с его совестью статические методы класса считаются безопасными.
>>
>> Дружественные ф-ции по определению пишет кто-то другой. А потому они вообще не обязаны сохранять инварианты класса, разве что была "нотариально-prooved-заверенная договорённость между программистами", и то не факт, что этого будет достаточно. 
>>
>> Хуже того, в классах, дружественных нашему, любой метод друга способен нарушить инвариант нашего класса. 
>>
>> Ещё хуже того, в шаблонных классах, дружественных нашему, на это способен любой метод, любой специализации этого друга.

Таким образом, если мы точно не уверены в том, что нам ПОЗАРЕЗ нужен `friend`, лучше не надо.

Эти ситуации, конечно, бывают, но они редки.

Особенно это касается *RAII*-классов. `friend` внутри *RAII*-класса <u>смертелен</u>.

---

### [**Статические функции-конструкторы**](https://youtu.be/LDoCQzSd3xo?t=587)
Имеется ввиду, что можно написать `static` аннотированную функцию внутри класса, которая будет конструировать объект. Этакий *C-style* конструктор.

```c++
template <typename T> class Matrix {
  // некое представление
 public:
  // конструктор для создания матрицы, заполненной значением
  Matrix(int cols, int rows, T val = T{});

  // конструктор для создания из заданной последовательности
  template <typename It>
  Matrix(int cols, int rows, It start, It fin);

  // "конструктор" для создания единичной матрицы;
  // в идентификаторе отсылочка к matlab-у
  static Matrix eye(int n, int m);
};
```
Конечно, `eye` не подчиняется синтаксису *конструктора класса в C++*. Конструирование через `eye` - это вызов `eye`-функции и вызов копирующего конструктора от *pr-value*, которое вернула `eye(n,m)`.

```c++
int main() {
  Matrix E_3 = Matrix::eye(3,3);  // возможно RVO
  ...
}
```

---

Далее. Поскольку правило нуля в данном упражнении неприменимо, то мы не можем использовать функционал `std::vector` контейнера. А потому наш класс `Matrix` - это *RAII*-класс. То есть он управляет памятью, которой никто больше не управляет. А значит нам придётся написать для него нетривиальный деструктор + остальные 4 метода согласно правилу пяти.

## [Обязательная пятёрка](https://youtu.be/LDoCQzSd3xo?t=649)

```c++
template <typename T> class Matrix {
  // некое представление
  public:
  // копирующий и перемещающий конструктор
  Matrix(const Matrix &rhs);
  Matrix(Matrix &&rhs);

  // присваивание и перемещение
  Matrix& operator=(const Matrix &rhs);
  Matrix& operator=(Matrix &&rhs);

  // деструктор
  ~Matrix();
}
```
С другой стороны, если сущностное представление объекта `Matrix` (первое `private`-поле в теле класса `Matrix`) - это не сырой указатель на `T`, а некоторая обёртка над этим сырым указателем, то именно эта обёртка будет *RAII*-классом, в котором нужно удовлетворить правилу пяти.

> **Дополнение к предыдущей лекции**:</br>
> Оказывается, если написать только 3 метода:
> - деструктор,
> - копирующий конструктор,
> - копирующее присваивание,
>
> то остальные два заблокируются компилятором. Неявного определения не будет.

...

---

## [Знакомство с `noexcept` аннотацией](https://youtu.be/LDoCQzSd3xo?t=748)

Она для функций в *C++*. Здесь мы её только коснёмся, а вплотную обсудим в 12й лекции.

Если функция делает только примитивные операции над примитивными типами, e.g.

- присваивает что-нибудь к `int` переменной,
- меняет значения указателей,
- ...

т.е. если она не совершает манипуляций над более сложными (чем примитивы) типами, то можно навесить на неё аннотацию `noexcept`.
> **Вопрос**: что делает аннотация `noexcept` на функцию?
>> - Конкретный ответ будет дан позже, а пока думаем об этом так: она "обещает" компилятору, что из этой функции не *выбросится исключение*, а компилятор в связи с этим предусматривает определённые оптимизации.

Про исключения мы начнём говорить в 11й лекции. Пока что тизерим.

> **Вопросы**: 
> - какие именно оптимизации предусмотрит компилятор?
> - в каких ещё ситуациях имеет смысл вешать `noexcept`?
> - что будет если кто-то бросит исключение внутри `noexcept`-аннотированной функции?
>> - На первые два вопроса мы ответим позже. А последний проспойлерим.
>>
>> Исключение выброшенное внутри `noexcept`-аннотированной функции спровоцирует `exit(1)`, или, что то же самое `abort`, или, что то же самое `std::terminate`, т.е. резкое завершение работы программы без очистки памяти (без вызовов деструкторов для объектов, созданных конструкторами на текущий момент *runtime*-а). Это утечка, и это плохо.
>>
>> Само собой, пока мы не умеем обрабатывать исключения (ничего не `try`-им, и ничего не ловим), выброс любого из них равносилен `std::terminate` в независимости от того, аннотированна ли функция `noexcept` или нет.

В связи с этим, на текущий момент мы, конечно, можем вешать `noexcept`-аннотацию на всё подряд, но здравый смысл, совесть и скромность вдохновляют нас этого не делать. Чтобы не плодить плохих привычек, аннотируем функции `noexcept` лишь только в тех случаях, в которых мы уверены, что мы не врём.

Одна из ситуаций, в которой `noexcept`-аннотация безопасна - это правильно реализованные перемещающий конструктор и перемещающее присваивание в *RAII*-классах, ведь эти методы лишь обменивают значения между указателями. Это примитивная операция над примитивным типом.

```c++
template <typename T> class Matrix {
  ...
  // конструктор перемещения обещает, что из него
  Matrix(Matrix &&rhs) noexcept;  // не выбросится исключение

  // перемещающее присваивание обещает, что из него
  Matrix& operator=(Matrix &&rhs) noexcept;  // не выбросится исключение
  ...
};
```

---

Перечислим безопасные методы, которые дёргают информацию о матрице, при этом саму матрицу никак не модифицируют. Ещё их называют

## [Селекторы](https://youtu.be/LDoCQzSd3xo?t=850)

```c++
template <typename T> class Matrix {
  // некое представление

 public:  // базовые
  int ncols() const;  // возвращает число столбцов
  int nrows() const;  // возвращает число строк

 public:  // агрегатные
  
  // возвращает след матрицы
  T trace() const;  

  // предикат сравнения *this c other
  bool equal(const Matrix& other) const;

  // предикат отношения "<", в терминах конкретной нормы например
  bool less(const Matrix& other) const;  

  // дамп инф-ы о матрице в поток вывода.
  void dump(std::ostream& os) const;  
};
```

> **Вопрос**: а почему бы вместо селекторов `equal` и `less` не перегрузить операторы `==` и `<` ?
>> - На это есть конкретные логические соображения, о которых мы поговорим уже в следующей лекции, а пока запомним следующее: "*бинарные операторы для объектов класса нужно писать снаружи; внутри класса им чаще всего не место*".

## [Удобные модификаторы для матриц](https://youtu.be/LDoCQzSd3xo?t=1003)
Например мы хотим, чтобы интерфейс над матрицами умел их транспонировать, умножать на -1.
```c++
template <typename T> class Matrix {
  // некое представление
 public:
  Matrix& negate() &;  // умножает *this на -1 и возвращает его
  Matrix& transpose() &;  // транспонирует *this и возвращает его
  ...
};
```
В этих методах мы возвращаем состояние объектов по ссылке, а потому, чтобы эти ссылки не провисли, объекты, от которых эти методы вызываются не должны быть временными. В прошлой лекции мы узнали, как заблокировать вызов метода для временных объектов; их надо *l-ref*-аннотировать. Вот зачем нужен амперсанд после скобок.

> **Вопрос**: Почему мы не пишем метод `Matrix transpose()`? <br/> Т.е. тот, который бы возвращал транспонированную копию `*this`.
>> - потому что `Matrix transpose()` можно написать в терминах `Matrix& transpose()`, а обратно - нет. Первый метод подразумевает копирование `*this` и транспонирование копии. Второй - только транспонирование `*this`. Потом, если нам нужно будет создать транспонированную копию `*this`, то писать `Matrix transpose()` будет намного легче c уже имеющимся методом, возвращающим ссылку.

## [Доступ к элементам. Перегрузка `operator[]`](https://youtu.be/LDoCQzSd3xo?t=1119)
Отвлечемся. Допустим мы пишем класс, который должен напоминать вектор. Но весь `std::vector<T,alloc>` нам не нужен, а нужен лишь его ограниченный интерфейс до его шаблонной специализации на `int`. Потренеруемся и перегрузим для него `operator[]`.

```c++
class MyVector {
  std::vector<int> v_;

 public:
  int& operator[](int x) { return v_[x]; }
  int operator[](int x) const { return v_[x]; }
  // .... some stuff ....
};
```
Каких-то непредсказуемых спецсемантик для оператора индексатора нет. `x` - аргумент типа индексатора, которому, вообще говоря, корректнее быть `unsigned long`-ом, или `size_t`, но да ладно. Теперь

```c++
int main() {
  MyVector arr(/*some initialisation*/);
  arr[5] = 3; // эквивалентно arr.operator[](5) = 3;
  // присваивает пятому элементу объекта
  // нашей обёртки над std::vector значение 3
}
```

Обратно к нашим матрицам. <br/>
Матрицы - это 2-мерные массивы, 
> **Вопрос**: как для них перегружать оператор индексатор?

К сожалению особенность `operator[]` состоит в том, что в него не помещается больше одного аргумента.
```c++
template <typename T> class Matrix {
  // некое представление
 public:
  ...
  ??? operator[](int id) {return ???}  
}
```
<kbd>-std=c++23</kbd> можно перегрузить его с каким угодно кол-вом аргументов и обращаться к элементам многомерных массивов, как в Паскале: `arr[i,j,k]`. Но заниматься мы таким пока не будем, и синтаксис индексатора, который мы хотим для двумерных массивов - это двойные квадратные скобки.

По хорошему, если под "неким представлением" прячется, например, `T** owner_`, то можно было бы вернуть `owner_[id]` указатель, и дальше, стандартный интерфейс над указателями обеспечил бы нам возможность вызвать ещё одни `[]`. 

Но мы не хотим возвращать указатель `owner_[id]`, потому что наш класс *RAII*, и его инвариант:
> <div style="text-align: center"><i><b>Никто кроме меня не имеет доступа к указателям, которые я храню внутри себя.</i></b></div>

<br/> Если мы вернём `owner_[id]`, то мы нарушим инвариант нашего *RAII*-класса `Matrix`.

Один из способов разрешить эту ситуацию - описать изолированный интерфейс для доступа к внутренностям и этот интерфейс может представлять из себя следующий класс-обёртку.
В теле `Matrix` пишем структуру `ProxyLine`, с указателем и перегруженным оператором индексатором:

```c++
template<typename T> class Matrix {
  // некое представление
  struct ProxyLine {
    T *line;
    T& operator[](int row_id) { return line[row_id]; }
    T operator[](int row_id) const { return line[row_id]; }
  };

  // <- сюда можно добавить поле связанное с ProxyLine

 public:
  ...
  ProxyLine operator[](int line_id) { return lines[line_id]; }
  const ProxyLine operator[](int line_id) const { return lines[line_id]; }
  ...
};
```
В означенное поле, могут быть некоторым образом захвачены данные, заинкапсулированные в `Matrix`. Желательно, конечно, внутрь таких *proxy*-сущностей владение не отдавать, а материализовать их на месте, использовать для доступа к внутренностям и отпускать.

Таким образом, ни на каком из этапов вызова `[i][j]` не произойдёт утечки указателя при попытке доступиться до элемента матрицы в позиции $(i,j)$. Речь о нормативном использовании; само собой, если захотеть, то до заинкапсулированного указателя всегда можно добраться.

Идея:
><div style="text-align: center"><b>использования <i>proxy</i>-классов, которые изолированы контексте реализации целевого класса, что-то внутрь себя захватили, перегрузили операторы и выдали наружу результат перегрузки</b></div>

<br/> является очень плодотворной, когда нам, например, нужно описать цепочку операторов для доступа в заинкапсулированные данные. Эта идея полезна не только в этом примере, и выручит нас ещё не раз.

<div style="text-align: right">Про проектирование матриц на этом всё.</div> 

#

На настоящий момент попробовали перегрузить следующие операторы
- приведение (из "нас" в другой тип)
- присваивание (перемещающее и копирующее)
- разыменование (звёздочка без аргументов)
- стрелочка (с *drill-down*-поведением)
- индексатор (квадратные скобки)

Оказывается, что все эти операторы могут быть только методами класса. Вне класса эти методы переопределить нельзя. То есть вне класса нельзя <u>объявить</u> и перегрузить
- оператор приведения с одним аргументом
- `operator=` с двумя аргументами 
- `operator*` с одним аргументом (с двумя - можно)
- `operator->` с двумя аргументами 
- `operator[]`

Для матриц можно перегрузить и другие операторы. Например "*умножения строка $\times$ столбец*" или "*умножение на скаляр*". Поскольку они бинарные, то, как мы уже где-то выше сказали, внутри класса им не место. Но не сказали почему. Об этом позже.

Перед тем, как окунуться в перегрузку операторов, нам нужно будет поговорить о **приведении типов**. Но перед этим отвлечёмся и слегка познакомимся с полезным *RAII*-инструментом стандартной библиотеки.

# [`Тизер возможностей std::unique_ptr`](https://youtu.be/LDoCQzSd3xo?t=1543)
