# [Лекция 6: Проектирование матриц (продолжение)](https://youtu.be/LDoCQzSd3xo)
На примере задач, которое оно ставит, очень удобно рассмотреть некоторые языковые механизмы.

Итак, проектирование.

## [***Матричные конструкторы***](https://youtu.be/LDoCQzSd3xo?t=54)

###
Как конструировать? Ну, первая идея - написать такой контсруктор, который ест число строк, столбцов и значениЕ, которЫМ надо матрицу заполнить.

```c++
template<typename T> class Matrix {
  // некое представление (т.е. указатель, куда будет выделяться память)
 public:
  /* конструктор для создания матрицы, 
   * заполненной конкретным значением, если конкретное указано,
   * или значением по умолчанию, иначе. */
  Matrix(int cols, int rows, T val = T{});

  /* конструктор для создания матрицы,
   * заполненой данными, расположенными
   * между итераторами start,fin (обобщенными указателями)
   * предполагая, что (fin - start) == (cols * rows) |-> true */
  template <typename It>
  Matrix(int cols, int rows, It start, It fin);
   ...
};
```
Про итераторы мы поговорим позже, а пока будем мыслить их, как к указатели, к которым можно применить `++` и они сдвигаются на следующее значение внутри некоторой коллекции. 

С матрицами, порой, хочется написать очень много конструкторов. Например
- тот, что будет создавать диагональную матрицу по заданному значению(ям)
- тот, что будет создавать верхне-треугольную матрицу
- ...

Можно, например, создать тегирующий `enum` тип внутри нашего класса, насоздавать там наименований, которые тегируют желаемый вид матрицы. Потом передавать тег в конструктор, который в свою очередь и будет создавать соответствующую матрицу. К сожалению это выглядит криво.

В таких случаях изящнее будет использовать в качестве конструкторов **статические функции класса**.

---

### [**`Static` и `friend` аннотированные методы**](https://youtu.be/LDoCQzSd3xo?t=295)
**Методы-члены класса** - это функции, которые имеют неявный аргумент `this`- указатель на объект, от которого и вызывается этот метод.
<u>Внутри реализации метода-члена класса мы имеем полный доступ к внутреннему состоянию любого объекта этого класса (т.е. в том числе к его приватным полям)</u>. Это мы знаем.

**Статические методы класса** - это функции, аннотированные `static`. Они вызываются БЕЗ неявного аргумента `this`, и для них `class`, в котором они находятся - это всё равно что `namespace` (причём их можно вызывать и от объектов класса, и через `MyNamespace::static_func(...)`). При этом, <u>внутри их реализации мы имеем полный доступ к внутреннему состоянию любого объекта этого класса</u>.

И есть ещё **дружественные методы класса**. Аннотация `friend` на метод, объявленный внутри класса, говорит, что если где-то снаружи есть функция с такой же сигнатурой, то <u>внутри её реализации программист будет иметь полный доступ к внутреннему состоянию любого объекта этого класса</u>, в котором эта ф-ция аннотирована `friend`.

И, как можно догадаться, последнее очень опасно.

```c++
class S {
  int x = 0;
 public:
  int get_x() const { return x; }  // метод-член
  static int s_get_x(const S *s) { return s->x; }  // статический метод
  friend int f_get_x(const S *s);  // дружественный метод
};

int f_get_x(const S *s) { return s->x; }
```
Удобна табличка в виде нижне-треугольной матрицы:
|   | методы-члены | статические</br> функции | друзья |
| - | - | - | - |
| получает неявный аргумент</br>`this` указатель | да | нет | нет |
| находится в</br> пространстве имен</br> класса | да | да | нет |
| имеет доступ к</br> закрытому состоянию</br> класса | да | да | да |

Класс умеет дружить не только с функциями, но и с целыми классами. Более того не исключена дружба с целыми шаблонами. Достаточно просто объявить соответствующую сущноть в теле и аннотировать её `friend`.
> **Вопрос**: Почему `friend` в *C++* - это плохо?
>> - Когда мы дойдём до шаблонов, мы об этом подробнее поговорим. Но сейчас it's safe to say: "<u>в общем случае в *C++* иметь друзей - это ошибка</u>".
>>
>> Статические методы класса определяет, или хотя бы объявляет, программист, который проектирует класс. Они - часть интерфейса класса, пространства имён и исходной задумки проектировщика класса, который скорее заботится о безопасности использования своего инструмента. В контексте этих неявных договорных отношений с совестью статические методы класса считаются безопасными.
>>
>> Дружественные ф-ции по определению пишет кто-то другой. А потому они вообще не обязаны сохранять инварианты класса, разве что была "нотариально-prooved-заверенная договорённость между программистами", и то не факт, что этого будет достаточно. 
>>
>> Хуже того, в классах, дружественных нашему, любой метод друга способен нарушить инвариант нашего класса. 
>>
>> Ещё хуже того, в шаблонных классах, дружественных нашему, на это способен любой метод, любой специализации этого друга.

Таким образом, если мы точно не уверены в том, что нам ПОЗАРЕЗ нужен `friend`, лучше не надо.

Эти ситуации, конечно, бывают, но они редки.

Особенно это касается *RAII*-классов. `friend` внутри *RAII*-класса <u>смертелен</u>.

---

### [**Статические функции-конструкторы**](https://youtu.be/LDoCQzSd3xo?t=587)
Имеется ввиду, что можно написать `static` аннотированную функцию внутри класса, которая будет конструировать объект. Этакий *C-style* конструктор.

```c++
template <typename T> class Matrix {
  // некое представление
 public:
  // конструктор для создания матрицы, заполненной значением
  Matrix(int cols, int rows, T val = T{});

  // конструктор для создания из заданной последовательности
  template <typename It>
  Matrix(int cols, int rows, It start, It fin);

  // "конструктор" для создания единичной матрицы;
  // в идентификаторе отсылочка к matlab-у
  static Matrix eye(int n, int m);
};
```
Конечно, `eye` не подчиняется синтаксису *конструктора класса в C++*. Конструирование через `eye` - это вызовы `eye`-функции и копирующего конструктора от *pr-value*, которое вернула `eye(n,m)`.

```c++
int main() {
  Matrix E_3 = Matrix::eye(3,3);  // возможно RVO
  ...
}
```

---

Далее. Поскольку правило нуля в данном упражнении неприменимо, то мы не можем использовать функционал `std::vector` контейнера. А потому наш класс `Matrix` - это *RAII*-класс. То есть он управляет памятью, которой никто больше не управляет. А значит нам придётся написать для него нетривиальный деструктор + остальные 4 метода согласно правилу пяти.

## [*RAII*-база](https://youtu.be/LDoCQzSd3xo?t=649)

```c++
template <typename T> class Matrix {
  // некое представление
  public:
  // копирующий и перемещающий конструктор
  Matrix(const Matrix &rhs);
  Matrix(Matrix &&rhs);

  // присваивание и перемещение
  Matrix& operator=(const Matrix &rhs);
  Matrix& operator=(Matrix &&rhs);

  // деструктор
  ~Matrix();
}
```
С другой стороны, если сущностное представление объекта `Matrix` - это не сырой указатель на `T`, а некоторая обёртка над этим сырым указателем, то именно эта обёртка будет *RAII*-классом, в которой нужно удовлетворить правилу пяти.

> **Дополнение к предыдущей лекции**:</br>
> Оказывается, если написать только 3 метода:
> - деструктор,
> - копирующий конструктор,
> - копирующее присваивание,
>
> то остальные два заблокируются компилятором. Неявного определения не будет.

...

---

## [Знакомство с `noexcept` аннотацией](https://youtu.be/LDoCQzSd3xo?t=748)

Она для функций в *C++*. Здесь мы её только коснёмся, а вплотную обсудим в 12й лекции.

Если функция делает только примитивные операции над примитивными типами, e.g.


Основной текст

>>>

Скрытый текст

<<<