# [Лекция 6: Проектирование матриц (продолжение)](https://youtu.be/LDoCQzSd3xo)
На примере задач, которое оно ставит, очень удобно рассмотреть некоторые языковые механизмы.

Итак, проектирование.

## [***Матричные конструкторы***](https://youtu.be/LDoCQzSd3xo?t=54)

Как конструировать? Ну, первая идея - написать такой контсруктор, который ест число строк, столбцов и значениЕ, которЫМ надо матрицу заполнить.

```c++
template<typename T> class Matrix {
  // некое представление (т.е. указатель, куда будет выделяться память)
 public:
  /* конструктор для создания матрицы, 
   * заполненной конкретным значением, если конкретное указано,
   * или значением по умолчанию, иначе. */
  Matrix(int cols, int rows, T val = T{});

  /* конструктор для создания матрицы,
   * заполненой данными, расположенными
   * между итераторами start,fin (обобщенными указателями)
   * предполагая, что (fin - start) == (cols * rows) |-> true */
  template <typename It>
  Matrix(int cols, int rows, It start, It fin);
   ...
};
```
Про итераторы мы поговорим позже, а пока будем мыслить их, как к указатели, к которым можно применить `++` и они сдвигаются на следующее значение внутри некоторой коллекции. 

С матрицами, порой, хочется написать очень много конструкторов. Например
- тот, что будет создавать диагональную матрицу по заданному значению(ям)
- тот, что будет создавать верхне-треугольную матрицу
- ...

Можно, например, создать тегирующий `enum` тип внутри нашего класса, насоздавать там наименований, которые тегируют желаемый вид матрицы. Потом передавать тег в конструктор, который в свою очередь и будет создавать соответствующую матрицу. К сожалению это выглядит криво.

В таких случаях изящнее будет использовать в качестве конструкторов **статические функции класса**.

---

### [**`Static` и `friend` аннотированные методы**](https://youtu.be/LDoCQzSd3xo?t=295)
**Методы-члены класса** - это функции, которые имеют неявный аргумент `this`- указатель на объект, от которого и вызывается этот метод.
<u>Внутри реализации метода-члена класса мы имеем полный доступ к внутреннему состоянию любого объекта (достижимого внутри тела реализации метода) этого класса (т.е. в том числе к его приватным полям)</u>. Это мы знаем.

В дальнейшем будем говорить просто: "доступ к внутреннему состоянию класса", подразумевая то, что описано выше.

**Статические методы класса** - это функции, аннотированные `static`. Они вызываются БЕЗ неявного аргумента `this`, и для них `class`, в котором они находятся - это всё равно что `namespace` (причём их можно вызывать и от объектов класса, и через `MyNamespace::st_func(...)`). При этом, <u>внутри их реализации мы имеем полный доступ к внутреннему состоянию класса</u>.

И есть ещё **дружественные методы класса**. Аннотация `friend` на метод, объявленный внутри класса, говорит, что если где-то снаружи есть функция с такой же сигнатурой, то <u>внутри её реализации программист будет иметь полный доступ к внутреннему состоянию класса</u>, в котором эта ф-ция аннотирована `friend`.

И, как можно догадаться, последнее очень опасно.

```c++
class S {
  int x = 0;
 public:
  int get_x() const { return x; }  // метод-член
  static int s_get_x(const S *s) { return s->x; }  // статический метод
  friend int f_get_x(const S *s);  // дружественный метод
};

int f_get_x(const S *s) { return s->x; }
```
Удобна табличка в виде нижне-треугольной матрицы:
|   | методы-члены | статические</br> функции | друзья |
| - | - | - | - |
| получает неявный аргумент</br>`this` указатель | да | нет | нет |
| находится в</br> пространстве имен</br> класса | да | да | нет |
| имеет доступ к</br> закрытому состоянию</br> класса | да | да | да |

Класс умеет дружить не только с функциями, но и с целыми классами. Более того не исключена дружба с целыми шаблонами. Достаточно просто объявить соответствующую сущноть в теле и аннотировать её `friend`.
> **Вопрос**: Почему `friend` в *C++* - это плохо?
>> - Когда мы дойдём до шаблонов, мы об этом подробнее поговорим. Но сейчас it's safe to say: "<u>в общем случае в *C++* иметь друзей - это ошибка</u>".
>>
>> Статические методы класса определяет, или хотя бы объявляет, программист, который проектирует этот класс. Они - часть интерфейса класса, пространства имён и исходной задумки проектировщика класса, который скорее всего заботится о безопасности использования своего инструмента. В контексте этих неявных договорных отношений проектировщика с его совестью статические методы класса считаются безопасными.
>>
>> Дружественные ф-ции по определению пишет кто-то другой. А потому они вообще не обязаны сохранять инварианты класса, разве что была "нотариально-prooved-заверенная договорённость между программистами", и то не факт, что этого будет достаточно. 
>>
>> Хуже того, в классах, дружественных нашему, любой метод друга способен нарушить инвариант нашего класса. 
>>
>> Ещё хуже того, в шаблонных классах, дружественных нашему, на это способен любой метод, любой специализации этого друга.

Таким образом, если мы точно не уверены в том, что нам ПОЗАРЕЗ нужен `friend`, лучше не надо.

Эти ситуации, конечно, бывают, но они редки.

Особенно это касается *RAII*-классов. `friend` внутри *RAII*-класса <u>смертелен</u>.

---

### [**Статические функции-конструкторы**](https://youtu.be/LDoCQzSd3xo?t=587)
Имеется ввиду, что можно написать `static` аннотированную функцию внутри класса, которая будет конструировать объект. Получится этакий *C-style* конструктор, который находится в пространстве имён нашего класса.

```c++
template <typename T> class Matrix {
  // некое представление
 public:
  // конструктор для создания матрицы, заполненной значением
  Matrix(int cols, int rows, T val = T{});

  // конструктор для создания из заданной последовательности
  template <typename It>
  Matrix(int cols, int rows, It start, It fin);

  // "конструктор" для создания единичной матрицы;
  // в идентификаторе отсылочка к matlab-у
  static Matrix eye(int n, int m);
};
```
Конечно, `eye` не подчиняется синтаксису *конструктора класса в C++*. Конструирование через `eye` - это вызов `eye`-функции и вызов копирующего конструктора от *pr-value*, которое вернула `eye(n,m)`.

```c++
int main() {
  Matrix E_3 = Matrix::eye(3,3);  // возможно RVO
  ...
}
```

---

Далее. Поскольку правило нуля в данном упражнении неприменимо, то мы не можем использовать функционал `std::vector` контейнера. А потому наш класс `Matrix` - это *RAII*-класс. То есть он управляет памятью, которой никто больше не управляет. А значит нам придётся написать для него нетривиальный деструктор + остальные 4 метода согласно правилу пяти.

## [Обязательная пятёрка](https://youtu.be/LDoCQzSd3xo?t=649)

```c++
template <typename T> class Matrix {
  // некое представление
  public:
  // копирующий и перемещающий конструктор
  Matrix(const Matrix &rhs);
  Matrix(Matrix &&rhs);

  // присваивание и перемещение
  Matrix& operator=(const Matrix &rhs);
  Matrix& operator=(Matrix &&rhs);

  // деструктор
  ~Matrix();
}
```
С другой стороны, если сущностное представление объекта `Matrix` (первое `private`-поле в теле класса `Matrix`) - это не сырой указатель на `T`, а некоторая обёртка над этим сырым указателем, то именно эта обёртка будет *RAII*-классом, в котором нужно удовлетворить правилу пяти.

> **Дополнение к предыдущей лекции**:</br>
> Оказывается, если написать только 3 метода:
> - деструктор,
> - копирующий конструктор,
> - копирующее присваивание,
>
> то остальные два заблокируются компилятором. Неявного определения не будет.

...

---

## [Знакомство с `noexcept` аннотацией](https://youtu.be/LDoCQzSd3xo?t=748)

Она для функций в *C++*. Здесь мы её только коснёмся, а вплотную обсудим в 12й лекции.

Если функция делает только примитивные операции над примитивными типами, e.g.

- присваивает что-нибудь к `int` переменной,
- меняет значения указателей,
- ...

т.е. если она не совершает манипуляций над более сложными (чем примитивы) типами, то можно навесить на неё аннотацию `noexcept`.
> **Вопрос**: что делает аннотация `noexcept` на функцию?
>> - Конкретный ответ будет дан позже, а пока думаем об этом так: она "обещает" компилятору, что из этой функции не *выбросится исключение*, а компилятор в связи с этим предусматривает определённые оптимизации.

Про исключения мы начнём говорить в 11й лекции. Пока что тизерим.

> **Вопросы**: 
> - какие именно оптимизации предусмотрит компилятор?
> - в каких ещё ситуациях имеет смысл вешать `noexcept`?
> - что будет если кто-то бросит исключение внутри `noexcept`-аннотированной функции?
>> - На первые два вопроса мы ответим позже. А последний проспойлерим.
>>
>> Исключение выброшенное внутри `noexcept`-аннотированной функции спровоцирует `exit(1)`, или, что то же самое `abort`, или, что то же самое `std::terminate`, т.е. резкое завершение работы программы без очистки памяти (без вызовов деструкторов для объектов, созданных конструкторами на текущий момент *runtime*-а). Это утечка, и это плохо.
>>
>> Само собой, пока мы не умеем обрабатывать исключения (ничего не `try`-им, и ничего не ловим), выброс любого из них равносилен `std::terminate` в независимости от того, аннотированна ли функция `noexcept` или нет.

В связи с этим, на текущий момент мы, конечно, можем вешать `noexcept`-аннотацию на всё подряд, но здравый смысл, совесть и скромность вдохновляют нас этого не делать. Чтобы не плодить плохих привычек, аннотируем функции `noexcept` лишь только в тех случаях, в которых мы уверены, что мы не врём.

Одна из ситуаций, в которой `noexcept`-аннотация безопасна - это правильно реализованные перемещающий конструктор и перемещающее присваивание в *RAII*-классах, ведь эти методы лишь обменивают значения между указателями. Это примитивная операция над примитивным типом.

```c++
template <typename T> class Matrix {
  ...
  // конструктор перемещения обещает, что из него
  Matrix(Matrix &&rhs) noexcept;  // не выбросится исключение

  // перемещающее присваивание обещает, что из него
  Matrix& operator=(Matrix &&rhs) noexcept;  // не выбросится исключение
  ...
};
```

---

Перечислим безопасные методы, которые дёргают информацию о матрице, при этом саму матрицу никак не модифицируют. Ещё их называют

## [Селекторы](https://youtu.be/LDoCQzSd3xo?t=850)

```c++
template <typename T> class Matrix {
  // некое представление

 public:  // базовые
  int ncols() const;  // возвращает число столбцов
  int nrows() const;  // возвращает число строк

 public:  // агрегатные
  
  // возвращает след матрицы
  T trace() const;  

  // предикат сравнения *this c other
  bool equal(const Matrix& other) const;

  // предикат отношения "<", в терминах конкретной нормы например
  bool less(const Matrix& other) const;  

  // дамп инф-ы о матрице в поток вывода.
  void dump(std::ostream& os) const;  
};
```

> **Вопрос**: а почему бы вместо селекторов `equal` и `less` не перегрузить операторы `==` и `<` ?
>> - На это есть конкретные логические соображения, о которых мы поговорим уже в следующей лекции, а пока запомним следующее: "*бинарные операторы для объектов класса нужно писать снаружи; внутри класса им чаще всего не место*".

## [Удобные модификаторы для матриц](https://youtu.be/LDoCQzSd3xo?t=1003)
Например мы хотим, чтобы интерфейс над матрицами умел их транспонировать, умножать на -1.
```c++
template <typename T> class Matrix {
  // некое представление
 public:
  Matrix& negate() &;  // умножает *this на -1 и возвращает его
  Matrix& transpose() &;  // транспонирует *this и возвращает его
  ...
};
```
В этих методах мы возвращаем состояние объектов по ссылке, а потому, чтобы эти ссылки не провисли, объекты, от которых эти методы вызываются не должны быть временными. В прошлой лекции мы узнали, как заблокировать вызов метода для временных объектов; их надо *l-ref*-аннотировать. Вот зачем нужен амперсанд после скобок.

> **Вопрос**: Почему мы не пишем метод `Matrix transpose()`? <br/> Т.е. тот, который бы возвращал транспонированную копию `*this`.
>> - потому что `Matrix transpose()` можно написать в терминах `Matrix& transpose()`, а обратно - нет. Первый метод подразумевает копирование `*this` и транспонирование копии. Второй - только транспонирование `*this`. Потом, если нам нужно будет создать транспонированную копию `*this`, то писать `Matrix transpose()` будет намного легче c уже имеющимся методом, возвращающим ссылку.

## [Доступ к элементам. Перегрузка `operator[]`](https://youtu.be/LDoCQzSd3xo?t=1119)
Отвлечемся. Допустим мы пишем класс, который должен напоминать вектор. Но весь `std::vector<T,alloc>` нам не нужен, а нужен лишь его ограниченный интерфейс до его шаблонной специализации на `int`. Потренеруемся и перегрузим для него `operator[]`.

```c++
class MyVector {
  std::vector<int> v_;

 public:
  int& operator[](int x) { return v_[x]; }
  int operator[](int x) const { return v_[x]; }
  // .... some stuff ....
};
```
Каких-то непредсказуемых спецсемантик для оператора индексатора нет. `x` - аргумент типа индексатора, которому, вообще говоря, корректнее быть `unsigned long`-ом, или `size_t`, но да ладно. Теперь

```c++
int main() {
  MyVector arr(/*some initialisation*/);
  arr[5] = 3; // эквивалентно arr.operator[](5) = 3;
  // присваивает пятому элементу объекта
  // нашей обёртки над std::vector значение 3
}
```

Обратно к нашим матрицам. <br/>
Матрицы - это 2-мерные массивы, 
> **Вопрос**: как для них перегружать оператор индексатор?

К сожалению особенность `operator[]` состоит в том, что в него не помещается больше одного аргумента.
```c++
template <typename T> class Matrix {
  // некое представление
 public:
  ...
  ??? operator[](int id) {return ???}  
}
```
В <kbd>-std=c++23</kbd> можно перегрузить его с каким угодно кол-вом аргументов и обращаться к элементам многомерных массивов, как в Паскале: `arr[i,j,k]`. Но заниматься мы таким пока не будем, и синтаксис индексатора, который мы хотим для двумерных массивов - это двойные квадратные скобки.

По хорошему, если под "неким представлением" прячется, например, `T** owner_`, то можно было бы вернуть `owner_[id]` указатель, и дальше, стандартный интерфейс над указателями обеспечил бы нам возможность вызвать ещё одни `[]`. 

Но мы не хотим возвращать указатель `owner_[id]`, потому что наш класс *RAII*, и его инвариант:
> <div style="text-align: center"><i><b>Никто кроме меня не имеет доступа к указателям, которые я храню внутри себя.</i></b></div>

<br/> Если мы вернём `owner_[id]`, то мы нарушим инвариант нашего *RAII*-класса `Matrix`.

Один из способов разрешить эту ситуацию - описать изолированный интерфейс для доступа к внутренностям и этот интерфейс может представлять из себя следующий класс-обёртку.
В теле `Matrix` пишем структуру `ProxyLine`, с указателем и перегруженным оператором индексатором:

```c++
template<typename T> class Matrix {
  // некое представление
  struct ProxyLine {
    T *line;
    T& operator[](int row_id) { return line[row_id]; }
    T operator[](int row_id) const { return line[row_id]; }
  };

  // <- сюда можно добавить поле связанное с ProxyLine

 public:
  ...
  ProxyLine operator[](int line_id) { return lines[line_id]; }
  const ProxyLine operator[](int line_id) const { return lines[line_id]; }
  ...
};
```
В означенное поле, могут быть некоторым образом захвачены данные, заинкапсулированные в `Matrix`. Желательно, конечно, внутрь таких *proxy*-сущностей владение не отдавать, а материализовать их на месте, использовать для доступа к внутренностям и отпускать.

Таким образом, ни на каком из этапов вызова `[i][j]` не произойдёт утечки указателя при попытке доступиться до элемента матрицы в позиции $(i,j)$. Речь о нормативном использовании; само собой, если захотеть, то до заинкапсулированного указателя всегда можно добраться.

Идея:
><div style="text-align: center"><b>использования <i>proxy</i>-классов, которые изолированы контексте реализации целевого класса, что-то внутрь себя захватили, перегрузили операторы и выдали наружу результат перегрузки</b></div>

<br/> является очень плодотворной, когда нам, например, нужно описать цепочку операторов для доступа в заинкапсулированные данные. Эта идея полезна не только в этом примере, и выручит нас ещё не раз.

<div style="text-align: right">Про проектирование матриц на этом всё.</div> 

#

На настоящий момент мы попробовали перегрузить следующие операторы
- приведение (из "нас" в другой тип)
- присваивание (перемещающее и копирующее)
- разыменование (звёздочка без аргументов)
- стрелочка (с *drill-down*-поведением)
- индексатор (квадратные скобки)

Оказывается, что все эти операторы могут быть только методами класса. Вне класса эти методы переопределить нельзя. То есть вне класса нельзя <u>объявить</u> и перегрузить
- оператор приведения с одним аргументом
- `operator=` с двумя аргументами 
- `operator*` с одним аргументом (с двумя - можно)
- `operator->` с двумя аргументами 
- `operator[]`

Для матриц можно перегрузить и другие операторы. Например "*умножения строка $\times$ столбец*" или "*умножение на скаляр*". Поскольку они бинарные, то, как мы уже где-то выше сказали, внутри класса им не место. Но не сказали почему. Об этом позже.

Перед тем, как окунуться в перегрузку операторов, нам нужно будет поговорить о **приведении типов**. Но перед этим отвлечёмся и слегка познакомимся с полезным *RAII*-инструментом стандартной библиотеки.

# [`Тизер std::unique_ptr`](https://youtu.be/LDoCQzSd3xo?t=1543)
В прошлой лекции мы построили *RAII*-обёртку `ScopedPointer`. Напомним, как она выглядела:

```c++
template <typename T>
class ScopedPointer {
  T* ptr_;

 public:
  ScopedPointer(T* ptr = nullptr) : ptr_(ptr) {}
  
  ScopedPointer(const ScopedPointer& rhs) :
    ptr_(new T{*rhs.ptr_}) {}

  ScopedPointer(ScopedPointer&& rhs) : 
    ptr_(rhs.ptr_) {  rhs.ptr_ = nullptr; }

  ~ScopedPointer() { delete ptr_; }

 public:
  ScopedPointer& operator=(const ScopedPointer& rhs) {
    if (&rhs != this) return *this;
    delete ptr_;
    ptr_ = new T(*(rhs.ptr_));
    return *this;
  }

  ScopedPointer& operator=(ScopedPointer&& rhs) {
      if (&rhs != this) return *this;
      std::swap(ptr_, rhs.ptr);
      return *this;
  }

 public:
  T& operator*() { return *ptr_; };
  const T& operator*() const { return *ptr_; };
  T* operator->() { return ptr_; };
  const T* operator->() const { return ptr_; };

};
```
> **Вопрос**: А зачем нам `ScopedPointer` вообще нужен? (Это важно вспомнить)
>> - Написание  `ScopedPointer` было мотивировано необходимостью повтора интерфейса сырых указателей в контексте примера функции, выделяющей в динамической памяти объект произвольного типа, а по окончанию работы - освобождающей.
>> ```c++
>> template <typename S> int foo(int n) {
>>  S *p = new S{n}; 
>>  // .... some code ....
>>  if (condition) {
>>    delete p;
>>    return FAILURE;
>>  }  
>>  // .... some code ....
>>  delete p;
>>  return SUCCESS;
>> }
>> ```
>> Ответственность за освобождение ресурса лежала на реализации `foo`.
>>
>> Нам очень хотелось избавиться от необходимости всякий раз делать `delete`. Это можно обеспечить, локализовав эту ответственность в механизм деструктора некоторого класса, коим в последствие и являлся *RAII*-класс `ScopedPointer`.

Окей. Вспомнили.

Конструктор копирования `ScopedPointer` мы написали в предположении, что ресурс, который в него обёрнут является копируемым. Т.е. у `T` конструктор копирования не удалён.

Вообще говоря со стороны обёртки думать, что у `T` не будет удалено копирование, очень опрометчиво. Например мьютексы и файлы не являются копируемыми сущностями.

При этом практически любой разумно описанный ресурс является перемещаемым, т.к. передать владение над ресурсом всегда должно быть возможно.

Оказывается, нам не нужно было писать свою *RAII*-обёртку (разве что для примера). В стандарте, начиная с *C++11*, уже есть нужные *RAII*-обёртки на все случаи жизни, и их ещё называют *умными указателями*. И один из таких умных называется [**`std::unique_ptr`**](https://en.cppreference.com/w/cpp/memory/unique_ptr).

На входе следует знать следующее. 
> На том месте, где у `ScopedPointer` поле `T* ptr_`,<br/> у `std::unique_ptr` стоит что-то типа `T obj_`.

И это странно, т.к. возникает
> **закономерный вопрос**: если `std::unique_ptr` - это "указатель", а внутренний handler на объект - это не указатель, то как происходит удаление?

частичный ответ даёт его объявление:
```c++
template<
  class T,
  class Deleter = std::default_delete<T>
> class unique_ptr;
```
Это объявление мы пока не до конца понимаем, но оно намекает, что помимо типа, захватываемого объекта, класс специализируется по параметру `Deleter` в котором и лежит информация о том, как надо удалять/освобождать `T`. И по умолчанию этот "делетер" - суть нечто стандартное "`std::default_delete<T>`"

Возможно означенная странность заключается в том, что таким образом в `unique_ptr` можно завернуть всё что угодно, в том числе и `void`. Зачем это надо? - пока не понятно. 

Несмотря на все странности *RAII*-обёртка `std::unique_ptr` имеет привычный нам интерфейс указателя, за одним исключением:
> `unique_ptr` = уникальный указатель. Т.е. не копируемый.
```c++
unique_ptr(unique_ptr& rhs) = delete;
unique_ptr& operator= (const uniqie_ptr & rhs) = delete;

unique_ptr(unique_ptr&& rhs) : ptr_(rhs.ptr_) {
  rhs.ptr_ = nullptr;
}

unique_ptr& operator= (unique_ptr &&rhs) {
  swap(*this, rhs); return *this;
}
```
Копирующие конструкторы и присваивания в нём запрещены явно.

Всё, что умеет `unique_ptr` - это перемещать то, чем он управляет.

Напишем нашу `foo` с помощью `unique_ptr` и чуть-чуть изменим его для демонстрации передачи владения.

```c++
int bar(std::unique_ptr uptr);

int foo (int x, double y) {
  std::unique_ptr<MyRes> res{new MyRes(x, y)}; // захват
  // .... some code ....

  if (condition) {
    bar(std::move(res)); // корректная передача владения
    // <- на этой строке от res осталась лишь пустая оболочка
    return FAILURE;
  }

  // .... some code ....
  return SUCCESS; // res освобождается в деструкторе
}
```
Прежде, чем мы научимся его осознанно корректно удалять, нам, опять же, нужно будет поговорить о перегрузке операторов, и, возможно, о шаблонах.

Обратим внимание вот на что. В первой строчке реализации `foo` мы определили умный указатель `res`, просто передав в него объект выделенный через `new` от конструктора `MyRes`.
```c++
std::unique_ptr<MyRes> res{new MyRes(x, y)};
```
Есть куда более интересный способ инициализации:
```c++
auto res = std::make_unique<MyRes>(x,y);
```
Тип `auto` означает "догадайся по контексту". <br/>
`std::make_unique<T>` - это шаблонная функция, которая возвращает `unique_ptr<T>` и только его.

Значит компилятор догадается, что `res` имеет тип `unique_ptr<T>`. В данном случае `T = MyRes`.

> **Вопрос**: откуда функция `make_unique` знает, какие аргументы у конструктора класса `MyRes`?

...(минутка для осознания)

> Получается, если `make_unique` умеет захватывать любой ресурс, который мы подставим на место `T`, то аргументы `make_unique` будут зависить от конструктора `T`? Чего??!

Это инстанс вариативно-шаблонной магии, о которой мы поговорим во второй половине курса.

<br/>

> **Вопрос**: что можно сказать о захвате ресурса в `const uniqie_ptr`?
> ```c++
>const unique_ptr<MyRes> cptr{new MyRes(x, y)};
>```
>> - для такого умного указателя будет запрещено копирование, потому что он *unique*.<br/>
А так же будет запрещено перемещение, потому что он `const`.

И правда. Вспомним предыдущую лекцию. Всякое перемещение объекта синтаксически сопровождается его пробрасыванием через `std::move`. Если `cptr` - это константный `unique_ptr`, то `std::move(cptr)` - это константная правая ссылка на `unique_ptr`. Это `const &&`. А аргумент конструктора перемещения - это `&&`.

`const &&` никогда не пролезет в `&&`.

Таким образом, если мы не хотим, чтобы данный объект не имел возможности покинуть *scope* текущей функции, то `const unique_ptr` - это то, во что мы хотим этот объект захватить.

# [Литература:](https://youtu.be/LDoCQzSd3xo?t=1956)

# [Приведения типов](https://youtu.be/LDoCQzSd3xo?t=2145)