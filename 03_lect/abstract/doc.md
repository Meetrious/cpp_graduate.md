# Лекция 3 (Имена и сущности)

## Контекст
В прошлой лекции говорилось о такой штуке, как контекст в разных представлениях.
- Модуль в языке *С* - это контекст.  
- Даже ф-ция тоже по своему является контекстом в себе.
- В языке *C++* класс - это контекст.

Контекст в том смысле, что может инкапсулировать в себе данные.

- Статическая глобальная переменная, которая объявлена и определена в отдельном модуле кода на *C* **не видна** никому за пределами этого модуля.
- Статическая переменная, объявленная внутри ф-ции, **не видна** никому, кроме этой ф-ции.
- Приватный член класса **защищён от доступа по имени** со стороны внешних функций и методов наследующих классов.

В последнем никакой речи о сокрытии данных не идёт. Мы ничего не можем скрыть в *C++*, потому что мы живём в виртуальной памяти, где всё на виду. При большом желании можно привести указатель на объект к `(char*)` и, шагая по адресам адресной арифметикой, подступиться к приватным внутренностям объекта и изменить их.

Означенное сокрытие that is **защита от доступа по имени** - это механизм абстракции, который очень важен и позволяет нам сохранять инварианты класса.

Инвариант класса - это что-то, что не контролируется нормативными документами языка, но что в языке присутствует с учётом контекста решаемой задачи.

- Полигон "знает", что все его вершины отсортированы по кругу и что он выпуклый.
- Список "знает", что в нём нет петли.

"Знает" означает, что утверждение выполняется на всём продолжении жизни объекта.

Ну так вот. Старые добрые `malloc` и `free` ничего не знают о конструкторах и деструкторах. В том смысле, что протяжении их работы, никаких утверждений относительно необходимости, или отсутствия необходимости, вызова каких-то доп. ф-ций, работающих надо объектами, нет.

Поэтому, если есть класс с нетривиальным конструктором, или даже с конструктором по умолчанию (без аргументов), который некоторым образом задаёт начальное состояние объекта, и нам вздумается создать этот объект, или массив этих объектов, через `malloc`. Что мы получим?

> - `malloc` вернёт void указатель на объект, на который OS выделила память на куче. И сам объект будет инициализирован мусором. Никакой конструктор не будет вызван.

Инициализация объекта в неконсистентном состоянии нас не устраивает по понятным причинам. Нам нужен `malloc`, который бы знал о пользовательских типах в *C++*. То есть о тех, у которых при инициализации надо вызывать конструкторы.

---

## new и delete

В *C++* аллокация делается через `new` и `delete`. Они вызывают конструкторы и деструкторы создаваемых/удаляемых объектов соответственно. Более того мы заводим 2 варианта `new` и 2 варианта `delete`. Один комплект для одиночных объектов, другой - для массивов.

``` cpp
int *t = new int;
delete t;

int *p = new int[5]
delete [] p;
```
> **Вопрос**: Зачем их две, если `malloc` был только один?

Чтобы на него ответить, зададим

> **Другой вопрос**: а откуда `free` вообще знает, сколько освобождать? Ведь у `free` всего лишь один аргумент - указатель, память по которому надо освободить. Однако же через `malloc` можно выделить сколько угодно "байт" памяти, и `free` по полученному указателю освобождает и не ошибается в кол-ве.

Вспомним сигнатуру `malloc`:
```c
void* malloc(size_t size);  // size_t - это typedef для unsigned long
```
Т.е. `malloc` возвращает указатель на адрес в памяти, по которому ОС выделила динамической памяти в кол-ве `size`-шт. местных чаров.

И оказывается, что в позиции левее (т.е. ближе к `NULL`) от расположения первого элемента выделяется место в памяти, в которое складируется значение кол-ва байт, которое ф-ция `free` должна будет освободить.

Теперь мы можем ответить на первый вопрос.
>> - Затем, что оператор `delete` не читает (как оптимально с его стороны), сколько надо удалять перед удалением. А оператор `delete []` таки читает. Равно как и `new` не пишет напоминалку "сколько выделил", тогда как `new type[]` пишет.

В общем случае, если перепутать `free`, `delete` и `delete []`, следует ожидать UB и потому парность вызовов `<malloc, free>`, `<new type, delete>`, `<new type[], delete []>` относительно одного ресурса нарушать нельзя.

Единственный инструмент для гарантии того, что мы случайно не перепутаем вызовы - инкапсуляция. Вызываем нужные аллокаторы в конструкторах, нужных освободителей в деструкторах.

Для наглядности можно покомпилировать и заексплорить в gdb пример [newdelete.cc](https://github.com/tilir/cpp-graduate/blob/master/02-lrefs/newdelete.cc).

---

## Провисание ссылок

Пусть есть ситуация в `main`:

```cpp
int *iarr = new int[5];
int &r = iarr[2];
// .. smth
delete [] iarr;
```
> **Вопроc**: Что после всего этого стало с ссылкой `r`?

>> - говорят, что она "***провисла***". На английском это состояние звучит, как "***dangling***". Это означает, что ссылка(для указателей это состояние эссенциально в той же мере) связана с объектом, чьё "*время жизни*" закончилось.

***Время жизни*** переменной в *С/С++* - это совокупность всех моментов времени исполнения программы, в которых состояние этой переменной **валидно**. Т.е. в любой из моментов времени жизни переменной у процесса нашей программы есть доступ к её области памяти и ОС гарантирует, что никакой другой процесс эту память себе не заберёт (может расшарить, если она аннотирована ключевым словом `volatile`, но в личное безраздельное пользование не заберёт).

Естественный ограничитель времени жизни переменных в памяти <u>на стеке</u> - границы **области видимости** (*scope*). Они нам известны, как наиболее встречающие случаи фигурных скобок.

***Scope*** переменной - это совокупность мест в коде программы, откуда можно обратиться к объекту по имени.

```cpp
int a = 2;  // scope переменной a глобальный. К этой переменной есть доступ у любого подблока (будь то ф-ция, класс...) внутри текущего модуля.

void foo() {
  int b = a + 3;  // для инициализации b используется значение a. foo находится внутри области видимости a.
  if (b > 5) {
    int c = (a + b) / 2;  // if конструкция находится внутри области видимости переменных a и b.
  }
  b += c;  // область видимости c закончилось. Здесь попытка переопределения b через значение по имени, которое более недоступно. Ошибка компиляции.
}
```
Имя переменной вводится в *scope* в точке её объявления (point of declaration). И обычно эта точка находится в позиции, ПОСЛЕ того, как прозвучали тип и имя, и ДО первого инициализатора (до присваивающего равно, или скобочек аргументов конструктора). Время жизни переменной начинается по окончанию последнего инициализатора. Следующий пример очень редок и демонстрирует, как можно воспользоваться чем-то до рождения этого чего-то.

```cpp
int main() {
  int a = a;  // это не ошибка компиляции. Это UB
  ...
}
```

И это редкий/достаточно детский способ выстрелить в ногу, от которого отучиваются компиляцией с флагом `-Wall`, или `-Wextra`, когда учатся писать на *C*. Отучиваются с помощью правила: "явно инициализировать чем-нибудь конкретным и дефолтным переменные СРАЗУ после объявления".

Время жизни объектов выделенных <u>на куче</u> же умеют переживать окончание scope имён с ними связанных, и потому необходимо не забывать освобождать их руками.

На самом деле куда более частая ошибка -- использовать нечто, уже после смерти этого нечто. И вот мы обратно вернулись к провисанию ссылок/указателей.

Перечислим классические примеры провисания ссылок/указателей:

Уже знакомый:
```cpp
int a = 2;
void foo() {
  int b = a + 3; int *pc = nullptr;
  if (b > 5) {
    int c = (a + b) / 2; pc = &c
  }  // время жизни переменной с, как и её область видимости здесь кончается.

  b += *pc;  // указатель pc всё ещё указывает на область памяти переменной, которая уже умерла. Указатель pc "провис". "Попугай умер".
}
```

Теперь про тот, что был вначале темы:
```cpp
int *iarr = new int[5];
int &r = iarr[2];
// .. smth
delete [] iarr;  // ссылка r "провисла"

// и сама по себе провисшая ссылка - это не страшно.

// страшно, когда мы начинаем её использовать, и что-то с ней делать
r += 1;  // "бытие попугая исчерпано". То на что ссылается r больше не принадлежит этому процессу этой программы.
```

Другой популярный пример:
```cpp
int& foo() {
  int x = 42;
  return x;  // здесь значение x не скопируется никуда. Но возващаемый int& свяжется именно с этим умирающим в return объектом x.
}

int main() {
  int x = foo();  // "попугай почил и протух" в момент смерти int x в foo

  // компилятор эту хрень даже не заметит. Дай Бог если статический анализатор предупредит об этой ошибке.
}
```
Пример выше будет в той же степени провальным, если заменить сигнатуру внешней ф-ции `int& foo()` на `const int& foo()`. Да, мы говорили на прошлой лекции, что константные ссылки умеют продлевать время жизни временных объектов, но это не тот случай. Здесь никакого второго имени, или изобретения первого имени для выходного `x` не произойдёт, и `const int&` провиснет так же, как и `int&`.

> **Закономерный вопрос**:  А какой тогда вообще смысл возвращать `type&`, если внутри всё умрёт и нельзя ничего спасти.

>> - возвращаемый аргумент `type&` ф-ции может в целости вернуть ссылку на глобальную переменную, и на переменную в динамической памяти.

```cpp
int foo();  // из предыдущего примера

main {
  const int& lx = 0;
  int x = lx;  // это ок.
  
  const int &ly = 42 + foo();  // 
  int y = ly;  // тоже ок.

  // но если возвращаемый int в foo заменить на сonst int&,
  // или на int&, то ly провиснет.
}
```

Выучим полезное правило про временные объекты:
> ***Временный объект живёт до конца полного выражения!***

Не совсем понятно, что есть "полное выражение" (для меня это синтаксически корректная инструкция, заканчивающаяся "`;`"). Но полезный пример в связи с этим правилом следующий:

```cpp
struct S {
  int x;
  const int& y;
}

main {
  S obj1 = {1,2};  // произошла агрегатная инициализация, всё ок. Жизнь временного объекта "2" будет продлена на стековом фрейме, в котором был создан obj1

  // А теперь сделаем очень похожую вещь, только в куче:
  S *ptr = new S{1,2};  // безымянный S{1,2} - это временный объект (можно сказать "референс для конструирования объекта" для new), который попадёт в new, и последний попытается выделить память в куче для нового объекта типа S и свяжет "const int& y" c временным объектом 2 в безымянном S{1,2}. После этого выделения безымянный объект S{1,2} умрёт и временный "2" вместе с ним. new вернёт указатель на выделенный объект в ptr. Однако второе поле этого объекта будет невалидно. ptr->y провиснет, ведь "2" умерла вместе с S{1,2}.
}
```

Другой полезный урок, который предоставляет этот пример, следующий:

> ***Не надо использовать членов-ссылок в классах!***

Ну то есть никто не запрещает. Это можно делать, но только если это хорошо обосновано, что, видимо, редкость.

К счастью модифицируемые левые ссылки не связываются с временными объектами (r-value выражениями) и не продлевают им жизнь. И любую попытку связать компилятор отловит.

```cpp
int foo();
foo(1);  // ошибка компиляции

int &x = 1;  // ошибка компиляции.
```
> **Cпойлер**:<br/>
>! c r-value выражениями свяжутся модифицируемые правые ссылки. Но о них позже.

Сформулируем небольшое полезное наставление:

> ***К левым ссылкам надо относиться как к пластиковым стаканчикам. Пока мы берём их и используем - это безопасно, годно. А вот хранить, а уж тем более возвращать их после использования кому-то куда-то - скорее не вежливо, а в нашем контексте небезопасно.***

---

Поговорим про l-value ещё чуть-чуть.

## Decay (разложение, увядание, или деградирование) и l-values

Глянем на пример:

```cpp
int foo(const int & t) {
  return t;  // Что может быть бесполезнее?
}
```
Внутри `foo` мы относимся к переменной `t`, как к `int`-переменной (в смысле синтаксиса для её использования). Хотя на самом деле нам уже известно, что `t` - это гораздо более сложная штука в отличие от привычного `int`-объекта. Мы знаем что на самом деле `t` - это скорее разыменнованный указатель на реально существующий `int`-объект, находящийся в стековом фрейме некоторой ф-ции, в контексте которой по стечению обстоятельств была вызвана ф-ция `foo`. 

И вот это явление упрощения интерфейса над конкретным объектом (чей финальный интерфейс был более сложным) в контексте какого-нибудь блока (ф-ции, класса) называется ***decaying***.

Скорее более очевидным примером "увядания, или разложения, или деградирования" является передача объекта в функцию по аргументу, тип которого суть базовый класс для класса передаваемого объекта (через такое действие осуществляется динамический полиморфизм, и мы поговорим о том, что это означает, позже).

Другой пример, куда ближе, но слабее, который встречается даже в *C* - это имя массива.
```c
void foo(int);

main {
  int arr[5];
  int *t = arr + 3;  // ok
  foo(arr);  // ok
  arr = t  // fail
}
```
Имя `arr` - это не только имя массива. В сущности `arr` так же является именем указателя на первый элемент этого массива. Последняя интерпретация проще первой. 

> **Отвлечение**: Ну и да. `arr` сам по себе на самом деле не имеет тип `int*`. Поскольку этот `arr`-указатель нельзя подвинуть, то к нему в некоторой степени можно относиться как к объекту типа `int * const`.

При этом `arr` является вполне себе *l-value*, ведь оно имеет место в памяти, но учитывая его константность мы не можем его поставить слева от равенства в инструкции.

И вот мы неуклюже переключаемся на тему l-value. 

---

### left or location?

Надо понимать, что *r-value* и *l-value* - это не какое-то там свойство, или характеристика для переменных. **Это характеристика выражений**. В *С* концепция l-value означала left-hand-side value, т.е. то, что стоит от равенства слева. 

Одно из самых мистических выражений в *C*, это следующее:
```c
y = x;
```
И мистическое оно потому, что равенство в этом выражении вообще не симметрично, ибо оно означает скорее `y := x`. Равенство здесь не предикат, а операция присваивания. В этой связи от `x` требуется, чтобы это было какое-то подходящее для типа переменной `y` значение. А от `y` требуется, чтобы оно имело место в памяти, обращение по имени `у` к которому позволяло её модификацию. Т.е `y` здесь - это как разыменованный `nonconst`-указатель на место в памяти, к которому у процесса этой программы есть доступ.

Требования на `y` совершенно иные, по сравнению с требованиями на `x` в этой инструкции. И в *С*, в контексте этой инструкции, `y` - это *l-value*, а `x` - это *r-value*.

Вообще, результат вызова любой ф-ции в *С* является r-value выражением (да, действительно. На указателях я тоже проверял)

В *C++* же ф-ция может стоять слева от знака `=`. Потому что в *C++* появились левые ссылки. И ф-ции в коде на *C++* могут эти левые ссылки возвращать.

```cpp
int& foo();  // имеет смысл только если foo возвращает ссылку на глобальную переменную, или на динамически-аллоцированную внутри foo память.
foo() = x;  // это ок.
```

В связи с этим в *C++* в обозначении *l-value*, ***l*** стоит не за *left-hand-side*, а за ***location***. И в отношении инструкций вокруг знака`=` *l-value* означает, что: "*выражение, у которого есть адрес*".

В *C++11* появился более широкий термин: *generalised l-value*, или *gl-value*, который объединяет l-value-выражения c выражениями, которые имеют временное положение в памяти. И да, множество r-value выражений пересекается с множеством gl-value выражений. Об этих классификациях мы поговорим, когда доберёмся до r-value.

---

## Немножко про c-declaration, или самая странная вещь, которую Деннис Ритчи придумал для языка *С*