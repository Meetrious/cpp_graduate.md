# [Лекция 3 (Имена и сущности)](https://youtu.be/TQ5VPnKWqoY)

## Контекст
В прошлой лекции говорилось о такой штуке, как контекст в разных представлениях.
- Модуль в языке *С* - это контекст. <- (здесь под модулем подразумевается отдельная компиляционная единица, быть может без точки входа)
- Даже функция тоже по своему является контекстом в себе.
- В языке *C++* класс - это контекст.

Контекст в том смысле, что может инкапсулировать в себе данные.

- Статическая глобальная переменная, которая объявлена и определена в отдельном модуле кода на *C* **не видна** никому за пределами этого модуля.
- Статическая переменная, объявленная внутри функции, **не видна** никому, кроме этой функции.
- Приватный член класса **защищён от доступа по имени** со стороны внешних функций и методов прочих классов.

В последнем никакой речи о сокрытии данных не идёт. Мы ничего не можем скрыть в *C++*, потому что мы живём в виртуальной памяти, где всё на виду. При большом желании можно привести указатель на объект к `(char*)` и, шагая по адресам адресной арифметикой, подступиться к приватным внутренностям объекта и изменить их.

Означенное сокрытие that is **защита от доступа по имени** - это механизм абстракции, который очень важен и позволяет нам сохранять инварианты класса.

Инвариант класса - это что-то, что не контролируется нормативными документами языка, но что в языке присутствует с учётом контекста решаемой задачи.

- Полигон "знает", что все его вершины отсортированы по кругу и что он выпуклый.
- Список "знает", что в нём нет петли.

"Знает" означает, что утверждение выполняется втечение всей жизни объекта.

Ну так вот. Старые добрые `malloc` и `free` ничего не знают о конструкторах и деструкторах. В том смысле, что на протяжении их исполнения, никаких утверждений относительно необходимости, или отсутствия необходимости, вызова каких-то доп. функций, работающих надо объектами, нет.

Поэтому, если есть класс с нетривиальным конструктором, или даже с конструктором по умолчанию (без аргументов), который некоторым образом задаёт начальное состояние объекта, и нам вздумается создать этот объект, или массив этих объектов, через `malloc`. Что мы получим?

> - `malloc` вернёт void указатель на объект, на который OS выделила память на куче. И сам объект будет инициализирован мусором. Никакой конструктор не будет вызван.

Инициализация объекта в неконсистентном состоянии нас не устраивает по понятным причинам. Нам нужен `malloc`, который бы знал о пользовательских типах в *C++*. То есть о тех, у которых при инициализации надо вызывать конструкторы.

---

## [new и delete](https://youtu.be/TQ5VPnKWqoY?t=193)

В *C++* аллокация делается через `new` и `delete`. Они вызывают конструкторы и деструкторы создаваемых/удаляемых объектов соответственно. Более того мы заводим 2 варианта `new` и 2 варианта `delete`. Один комплект для одиночных объектов, другой - для массивов.

``` cpp
int *t = new int;
delete t;

int *p = new int[5]
delete [] p;
```
> **Вопрос**: Зачем их две, если `malloc` был только один?

Чтобы на него ответить, зададим

> **Другой вопрос**: а откуда `free` вообще знает, сколько освобождать? Ведь у `free` всего лишь один аргумент - указатель, память по которому надо освободить. Однако же через `malloc` можно выделить сколько угодно "байт" памяти, и `free` по полученному указателю освобождает и не ошибается в кол-ве.

Вспомним сигнатуру `malloc`:
```c
void* malloc(size_t size);  // size_t - это typedef для unsigned long
```
Т.е. `malloc` возвращает указатель на адрес в памяти, по которому ОС выделила динамической памяти в кол-ве `size`-шт. местных чаров.

И оказывается, что в позиции левее (т.е. ближе к `NULL`) от расположения первого элемента выделяется место в памяти, в которое складируется значение кол-ва байт, которое функция `free` должна будет освободить.

Теперь мы можем ответить на первый вопрос.
>> - Затем, что оператор `delete` не читает (как оптимально с его стороны), сколько надо удалять перед удалением. А оператор `delete []` таки читает. Равно как и `new` не пишет напоминалку "сколько выделил", тогда как `new type[]` пишет.

В общем случае, если перепутать `free`, `delete` и `delete []`, следует ожидать UB и потому парность вызовов `<malloc, free>`, `<new type, delete>`, `<new type[], delete []>` относительно одного ресурса нарушать нельзя.

Единственный инструмент для гарантии того, что мы случайно не перепутаем вызовы - инкапсуляция. Вызываем нужные аллокаторы в конструкторах, нужных освободителей в деструкторах.

Для наглядности можно покомпилировать и заексплорить в gdb пример [newdelete.cc](https://github.com/tilir/cpp-graduate/blob/master/02-lrefs/newdelete.cc). Или посмотреть, как это [сделал автор](https://youtu.be/TQ5VPnKWqoY?t=412).

---
## [Провисание ссылок](https://youtu.be/TQ5VPnKWqoY?t=687)

Пусть есть ситуация в `main`:

```cpp
int *iarr = new int[5];
int &r = iarr[2];
// .. smth
delete [] iarr;
```
> **Вопроc**: Что после всего этого стало с ссылкой `r`?

>> - говорят, что она "***провисла***". На английском это состояние звучит, как "***dangling***". Это означает, что ссылка(для указателей это состояние эссенциально в той же мере) связана с объектом, чьё "*время жизни*" закончилось.

***Время жизни*** переменной в *С/С++* - это совокупность всех моментов времени исполнения программы, в которых состояние этой переменной **валидно**. Т.е. в любой из моментов времени жизни переменной у процесса нашей программы есть доступ к её области памяти и ОС гарантирует, что никакой другой процесс эту память себе не заберёт (может расшарить, если она аннотирована ключевым словом `volatile`, но в личное безраздельное пользование не заберёт).

Естественный ограничитель времени жизни переменных в памяти <u>на стеке</u> - границы **области видимости** (*scope*). Они нам известны, как наиболее встречающие случаи фигурных скобок.

***Scope*** переменной - это совокупность мест в коде программы, откуда можно обратиться к объекту по имени.

```cpp
int a = 2;  // scope переменной a глобальный. К этой переменной
// есть доступ у любого подблока (будь то функция, класс...)
// внутри текущего модуля.

void foo() {
  int b = a + 3;  // для инициализации b используется значение a.
  // foo находится внутри области видимости a.

  if (b > 5) {
    int c = (a + b) / 2;  // if конструкция находится внутри 
    // области видимости переменных a и b.
  }

  b += c;  // область видимости c закончилось.
  // Здесь попытка переопределения b через значение по имени,
  // которое более недоступно. Ошибка компиляции.
}
```
Имя переменной вводится в *scope* в точке её объявления (point of declaration). И обычно эта точка находится в позиции, ПОСЛЕ того, как прозвучали тип и имя, и ДО первого инициализатора (до присваивающего равно, или скобочек аргументов конструктора). Время жизни переменной начинается по окончанию последнего инициализатора. Следующий пример очень редок и демонстрирует, как можно воспользоваться чем-то до рождения этого чего-то.

```cpp
int main() {
  int a = a;  // это не ошибка компиляции. Это UB
  ...
}
```
И это редкий пример выстрела в ногу.

Время жизни объектов выделенных <u>на куче</u> же умеют переживать окончание scope имён с ними связанных, и потому необходимо не забывать освобождать их руками.

На самом деле куда более частая ошибка -- использовать нечто, уже после смерти этого нечто. И вот мы обратно вернулись к провисанию ссылок/указателей.

Перечислим классические примеры провисания ссылок/указателей:

Уже знакомый:
```cpp
int a = 2;
void foo() {
  int b = a + 3; int *pc = nullptr;
  if (b > 5) {
    int c = (a + b) / 2; pc = &c
  }  // время жизни переменной с, как и её область видимости здесь кончается.

  b += *pc;  // указатель pc всё ещё указывает на область памяти переменной,
  // которая уже умерла. Указатель pc "провис". "Попугай умер".
}
```

Теперь про тот, что был вначале темы:
```cpp
int *iarr = new int[5];
int &r = iarr[2];
// .. smth
delete [] iarr;  // ссылка r "провисла"

// и сама по себе провисшая ссылка - это не страшно.

// страшно, когда мы начинаем её использовать, и что-то с ней делать
r += 1;  // "бытие попугая исчерпано". 
// То на что ссылается r больше не принадлежит этому процессу этой программы.
```

Другой популярный пример:
```cpp
int& foo() {
  int x = 42;
  return x;  // здесь значение x не скопируется никуда.
  // Но возващаемый int& свяжется именно с этим умирающим в return объектом x.
}

int main() {
  int x = foo();  // "попугай почил и протух" в момент смерти int x в foo.

  // компилятор эту хрень даже не заметит. 
  // Дай Бог если статический анализатор предупредит об этой ошибке.
}
```
Пример выше будет в той же степени провальным, если заменить сигнатуру внешней функции `int& foo()` на `const int& foo()`. Да, мы говорили на прошлой лекции, что константные ссылки умеют продлевать время жизни временных объектов, но это не тот случай. Здесь никакого второго имени, или изобретения первого имени для выходного `x` не произойдёт, и `const int&` провиснет так же, как и `int&`.

> **Закономерный вопрос**:  А какой тогда вообще смысл возвращать `type&`, если внутри всё умрёт и нельзя ничего спасти.

>> - возвращаемый аргумент `type&` функции может в целости вернуть ссылку на глобальную переменную, на переменную в динамической памяти, или, например, переменную, которую мы передали внутрь функции по ссылке (указателю).

```cpp
int foo();  // из предыдущего примера

main {
  const int& lx = 0;
  int x = lx;  // это ок.
  
  const int &ly = 42 + foo();  // 
  int y = ly;  // тоже ок.

  // но если возвращаемый int в foo заменить на сonst int&,
  // или на int&, то ly провиснет.
}
```

Выучим полезное правило про временные объекты:
> ***Временный объект живёт до конца полного выражения!***

Не совсем понятно, что есть "полное выражение" (для меня это синтаксически корректная инструкция, заканчивающаяся "`;`"). Но полезный пример в связи с этим правилом следующий:

```cpp
struct S {
  int x;
  const int& y;
}

main {
  S obj1 = {1,2};  // произошла агрегатная инициализация, всё ок.
  // Жизнь временного объекта "2" будет продлена на стековом фрейме,
  // в котором был создан obj1

  // А теперь сделаем очень похожую вещь, только в куче:
  S *ptr = new S{1,2};  /* безымянный S{1,2} - это временный объект 
  (можно сказать "референс для конструирования объекта" для new), 
  который попадёт в new, и последний попытается выделить
  память в куче для нового объекта типа S, и в случае успеха свяжет его
  "const int& y" c временным объектом "2" в безымянном S{1,2}.
  После этого выделения безымянный объект S{1,2} умрёт
  и временный "2" вместе с ним.
  new вернёт указатель на выделенный объект в ptr.
  Однако второе поле этого объекта будет невалидно.
  ptr->y провиснет, ведь "2" умерла вместе с S{1,2}. */
}
```

Другой полезный урок, который предоставляет этот пример, следующий:

> ***Не надо использовать членов-ссылок в классах!***

Ну то есть никто не запрещает. Это можно делать, но только если это хорошо обосновано, что, видимо, редкость.

К счастью модифицируемые левые ссылки не связываются с временными объектами (r-value выражениями) и не продлевают им жизнь. И любую попытку связать компилятор отловит.

```cpp
int foo();
foo(1);  // ошибка компиляции

int &x = 1;  // ошибка компиляции.
```
> **Cпойлер**:<br/>
>! c r-value выражениями свяжутся модифицируемые правые ссылки. Но о них позже.

Сформулируем небольшое полезное наставление:

> ***К левым ссылкам надо относиться как к пластиковым стаканчикам. Пока мы берём их и используем - это безопасно, годно. А вот хранить, а уж тем более возвращать их после использования кому-то куда-то - скорее не вежливо, а в нашем контексте небезопасно.***

---

Поговорим про l-value ещё чуть-чуть.

## [Decay (разложение, увядание, или деградирование) и l-values](https://youtu.be/TQ5VPnKWqoY?t=1465)

Глянем на пример:

```cpp
int foo(const int & t) {
  return t;  // Что может быть бесполезнее?
}
```
Внутри `foo` мы относимся к переменной `t`, как к `int`-переменной (в смысле синтаксиса для её использования). Хотя на самом деле нам уже известно, что `t` - это гораздо более сложная штука в отличие от привычного `int`-объекта. Мы знаем что на самом деле `t` - это скорее разыменнованный указатель на реально существующий `int`-объект, находящийся в стековом фрейме некоторой функции, в контексте которой по стечению обстоятельств была вызвана функция `foo`. 

И вот это явление упрощения интерфейса над конкретным объектом (чей финальный интерфейс был более сложным) в контексте какого-нибудь блока (функции, класса) называется ***decaying***.

Скорее более очевидным примером "увядания, или разложения, или деградирования" является передача объекта в функцию по аргументу, тип которого суть базовый класс для класса передаваемого объекта (через такое действие осуществляется динамический полиморфизм, и мы поговорим о том, что это означает, позже).

Другой пример, куда ближе, но слабее, который встречается даже в *C* - это имя массива.
```c
void foo(int);

main {
  int arr[5];
  int *t = arr + 3;  // ok
  foo(arr);  // ok
  arr = t  // fail
}
```
Имя `arr` - это не только имя массива. В сущности `arr` так же является именем указателя на первый элемент этого массива. Последняя интерпретация проще первой. 

> **Отвлечение**: Ну и да. `arr` сам по себе на самом деле не имеет тип `int*`. Поскольку этот `arr`-указатель нельзя подвинуть, то к нему в некоторой степени можно относиться, как к объекту типа `int * const`.

При этом `arr` является вполне себе *l-value*, ведь оно имеет место в памяти, но учитывая его константность мы не можем его поставить слева от равенства в инструкции.

И вот мы неуклюже переключаемся на тему l-value. 

---

### left or location?

Надо понимать, что *r-value* и *l-value* - это не какое-то там свойство, или характеристика для переменных. **Это характеристика выражений**. В *С* концепция l-value означала left-hand-side value, т.е. то, что стоит от равенства слева. 

Одно из самых мистических выражений в *C*, это следующее:
```c
y = x;
```
И мистическое оно потому, что равенство в этом выражении вообще не симметрично, ибо оно означает скорее `y := x`. Равенство здесь не предикат, а операция присваивания. В этой связи от `x` требуется, чтобы это было какое-то подходящее для типа переменной `y` значение. А от `y` требуется, чтобы оно имело место в памяти, обращение по имени `у` к которому позволяло её модификацию. Т.е `y` здесь - это как разыменованный неконстантный указатель на место в памяти, к которому у процесса этой программы есть доступ.

Требования на `y` совершенно иные, по сравнению с требованиями на `x` в этой инструкции. И в *С*, в контексте этой инструкции, `y` - это *l-value*, а `x` - это *r-value*.

Вообще, результат вызова любой функции в *С* является r-value выражением (да, действительно. На указателях я тоже проверял)

В *C++* же функция может стоять слева от знака `=`. Потому что в *C++* появились левые ссылки. И функции в коде на *C++* могут эти левые ссылки возвращать.

```cpp
int& foo();  // имеет смысл только если foo возвращает ссылку
//  на глобальную переменную, или
//  на динамически-аллоцированную внутри foo память.
foo() = x;  // это ок.
```

В связи с этим в *C++* в обозначении *l-value*, ***l*** стоит не за *left-hand-side*, а за ***location***. И в отношении инструкций вокруг знака `=` *l-value* означает, что: "*выражение, у которого есть постоянное место в памяти*".

В *C++11* появился более широкий термин: *generalised l-value*, или *gl-value*, который объединяет l-value-выражения c выражениями, которые имеют временное положение в памяти. И да, множество r-value-выражений пересекается с множеством gl-value-выражений. Об этих классификациях мы поговорим, когда доберёмся до r-value.

---

## [Cdecl и как замотивировать typedef в *C* и using в *C++*](https://youtu.be/TQ5VPnKWqoY?t=1854)

Зайдём со стороны ссылок/указателей на массив.
Вот есть объявления для двух объектов:
```cpp
int *x[20];
int (*y)[20];
```
> **Вопрос**: Чем являются эти объекты?

Чтобы уметь на него отвечать, надо уметь читать *си-выражения*, или *c-declarations*, или *cdecl* \[сидекл\]. Техника очень простая:
1. Находим имя, которое не является ключевым словом языка.
2. Произносим всё, что стоит правее имени, пока не уткнёмся в `)` или в `;`.
3. Утунулись. Произносим всё, что стоит левее имени, пока не уткнёмся в `(`, или в конец текущего выражения.
4. Уткнулись в `(` $\Rightarrow$ выходим из скобок.
5. Повторяем процесс с пункта 2, только теперь не в отношении имени, найденном в самом начале, а в отношении содержимого скобок, из которых вышли на предыдущем шаге. Повторяем, пока не прочитаем выражение до конца.

Первая строка читается:

x - это (\*идём вправо, видим `[20]`, говорим\*) массив из 20ти  (\*уткнулись в "`;`", идём влево от `х`, видим "`*`", говорим\*) указателей на 
  (\*идём влево дальше, видим "`int`", говорим\*) `int`.

Итого в первой строке объявлен *`x`, который является массивом из 20 указателей на переменные типа `int`.*

Во второй: *`y` суть указатель на массив из 20 элементов на `int`.*

> **Вопрос**: а в чём разница между `x` и `y`.

```cpp
int *x[20];  // массив из указателей
int (*y)[20];  // указатель на массив

x[1] == *(x + 1) == *(int**)((char*)x + 1 * sizeof(int*))
- это значение в первом указателе из массива x.
  (т.е. это первый из 20ти адресов, который ссылается на ячейку в памяти,
    в которой лежит какой-то int)


y[1] == *(y + 1) == *(int**)((char*)y + 1 * sizeof(int*[20])) 
- это указатель на следующий объект типа int[20]
  (т.е. указатель на следующий массив из 20ти элементов после текущего)
  (т.е. указатель на ячейку, в которой лежит 
        адрес первого (т.е. нулевого) элемента следующего int[20])
```
>> - Разница в том, как для них работает адресная арифметика.

В этом можно убедиться поиграв с примером на [godbolt](https://godbolt.org/z/EKG7vsnhP).

Пусть факт и не удивительный, но заметим, что ссылки на массив можно брать:
```cpp
int (*y)[20];  // указатель на массив
int (&z)[20] = *y;  // ссылка на массив

z - это адрес первого(т.е. нулевого) элемента текущего int[20].
```
Ну и ладно. Перейдём к чему-нибуть более проклятому.

```cpp
// здесь отправной объект называется "c"
char *(*(&c)[10])(int *&p);
/** c - это ссылка на массив из 10 указателей на функцию,
 * принимающую ссылку на указатель на переменную int, и
 * возвращающую указатель на переменную char. */

// здесь отправной объект называется "bar"
void (*bar(int x, void(*func)(int&))) (int&);
/** bar - это функция, которая принимает два аргумента x и func (о них позже) и
 * возвращает указатель на функцию, 
 *    принимающую ссылку на int, и ничего не возвращающую.
 *
 * В свою очередь bar принимает переменную int и указатель на функцию func,
 *    которая принимает ссылку на int и ничего не возвращает. */
```
Всё это читать мерзко, но в финале, когда получается понять, то приятно.
Однако, не стоит извращаться; умение читать сложный *cdecl* не означает, что его надо уметь/тренироваться писать. Сложность конструкций должна быть очень хорошо обоснована, и в *C* она порой да.

Заметим, что `bar` принимает в себя вторым аргументом объект того же типа, что и возвращает.
`bar` - это функция, которая принимает `int` и `void(*)(int&)`, и возвращает в точности `void(*)(int&)`. В языке *С* с подобной милотой боролись, используя **`typedef`**.

> **`typedef`** -- это ключевое слово в *C* для ввода в синтаксис нашего кода пользовательских псевдонимов для существующих типов.

Примеры:
```cpp
size_t - псевдоним для типа индексации массивов
        который на самом деле unsigned long.
typedef unsigned long size_t; /* <- именно так он определяется в
        хедерах стандартной библиотеки. */
```
И указатель на функцию - это тоже вполне себе тип. И оказывается, чтобы его typedef-нуть в *C*, мы не сначала пишем тип, и потом, как его обозвать, а по-другому:

```cpp
typedef void (*ptr_to_fref_t)(int&);  /* теперь ptr_to_fref_t - это псевдоним
        для типа "указатель на функцию берущую int& и возвращающую ничего". */
```

Теперь мы можем написать определение функции `bar` понятным образом без её обёрки в тип, который она возвращает.

```cpp
void (*bar(int x, void(*func)(int&))) (int&);  // было ужастно
ptr_to_fref bar(int x, ptr_to_fref_t func);  // стало прекрасно
```

В *С* нет шаблонов. А `typedef` из `С`. Значит `typedef` не умеет в шаблонные псевдонимы. Для этих целей (и ещё парочку других) в *C++* было определено ключевое слово **`using`**.

> **`using`** -- это ключевое слово в *C++*, суть которого та же, что и у `typedef`, только он чуть удобнее и умеет немного больше, чем последний.

Используя `using` можно переписать выше описанный `typedef` следующим образом:

```cpp
typedef void (*ptr_to_fref_t)(int&);  // было в Си
using ptr_to_fref_t = void (*)(int&);  // стало в С++
```
Т.е. с `typedef` нам нужно было зарываться внутрь выражения, чтобы понять, что же именно typedef-нуто. С `using` всё проще. По левую сторону от знака `=` стоит имя. По правую - имя чего. Строго. Понятно.

Более того, если вдруг вместо `int`-аргумента нас интересует шаблон, то `using` позволит нам его ввести, и создать целое семейство типов под нашим псевдонимом:

```cpp
template <typename T>
using ptr_to_fref_t = void (*)(T&);

// в частности можем объявить выше упомянутый bar
ptr_to_fref_t<int> bar(int x, ptr_to_fref_t<int> func);
```

---
## [Манглирование - то без чего *C++* остался бы *C*](https://youtu.be/TQ5VPnKWqoY?t=2324)

В `string.h`-хедере *C* объявлена функция, которая умеет в строке `const char* haystack` искать первое вхождение подстроки, совпадающей со строкой `const char* needle` и возвращать указатель на первую букву этого первого вхождения `needle` внутри `haystack`. Называется эта функция `strstr`:
```c
char* strstr(const char *haystack, const char *needle); 
```
> ***Вопрос***: Почему оба аргумента `const`, а результат `nonconst`? Ладно, пофиг даже на `needle`. Почему указатель на `haystack`, принимается константный, а возвращаемый аргумент - это неконстантный указатель из этой же строки??

>> - для обоих объектов ответ похожий: 
>>    * Если `haystack` будет неконстантным указателем на строку, то в него не пролезут константные указатели на строки.
>>    * Если `return`-аргумент будет константным указателем на строку, то мы не сможем приравнять его к объекту `char*` на выходе из `strstr`.

Другой довод для входных аргументов такой, что мол: "*аннотируя их `const`, автор `strstr`-функции нам вежливо обещает не изменять содержимое этих строк*". Что приятно, и тоже разумный ответ.

Но тот ответ, что выделен, куда более весомый. 

И ситуация, якобы, омерзительная. И в связи с ней мы бы хотели, чтобы было две функции `strstr`:
```c
char* strstr(char *haystack, const char *needle);
const char* strstr(const char *haystack, const char *needle);  
```
... хотели бы чтобы компилятор по типу принимающей результат `strstr` переменной, и по типу переменной, входящей в `haystack`, вызывал ту или другую.

Увы, <u>в *C* нельзя переопределять функции</u>. Но в *C++* стало можно. В хедере `cstring` она перегружена выше описанным образом. И в коде на *C++* константность первого аргумента `strstr` правильно согласована с константностью результата.

С функцией `sqrt` из `math.h` та же история. Там у нас объявлены
- `sqrt` для корня из `double`;
- `sqrtl` для корня из `long double`;
- `sqrtf` для корня из `float`. 

И ИМХО вот это куда более омерзительно, чем то, что нам хватило лишь одного инстанса описания `strstr`, но да ладно. В `cmath`-библиотеке языка *C++* она три раза перегружена для разных типов.

В *C* нельзя нельзя перегружать функции по одной очень хорошей причине. Более того эта причина делает язык *C* до сих пор живым. Т.е. язык *C* до сих пор жив только потому, что в *С* отсутствиет механизм, позволяющий, в частности, перегружать функции. Механизм, о котором идёт речь, называется **манглирование**.

> **Манглирование** - это (не дам строгого определения) механизм компиляторов С++ для искажения имён объектов в нашем коде при трансляции в ассемблер. 

Искажение хитрое, и по крайней мере для имён функций из глобала, их метка в ассемблере искажается в связи с их сигнатурой. Метка на выходе представляет из себя странное, но уникальное имя, в котором проглядывается исходное, а по бокам какой-то невнятный мусор, суть которого - некоторым образом закодированная сигнатура. 

Манглирование позволяет нам написать сколько угодно одинаково называющихся функций. И до тех пор, пока
- или их сигнатуры отличаются,
- и/или они расположены в разных классах,
- и/или они находятся в разных пространствах имён (о последних конце этой лекции),

их метка в ассемблере будет для каждой уникальна, а значит операционная система не перепутает какую и для чего вызвать.

В *C* нет манглирования. Если мы пишем в коде языка *C* какое-то имя, компиляторы языка *C* гарантируют, что в ассемблере это имя не будет искажено типом/типами, с которыми это имя связано. То есть язык *C* предоставляет нам гарантию по именам, что делает возможным общение других языков через его API. 

> ~*"Отсутствие манглирования означает стабильное API и стабильный ABI. Если, например, мы хотим на Python взаимодествовать с чем-то из C++, мы делаем на обоих С-интерфейс, т.к. С-интерфейс - это наш highest readable common level, читаемый ассемблер, место, где мы уверены, что на бинарном уровне у нас будут одинаковые имена и в финальной компиляции они слинкуются. Даже из двух разных компиляторов С++ для одной и той же функции могут получаться разные имена в ассемблере. Тупо взяли 2 модуля своей программы, один пропустили через clang++, другой пропустили через g++, они не слинкуются, если между ними нет С-интерфейса"*. 

Другая гарантия, которую даёт язык *C* - это то, что в *C* нет ничего неявного. Примером неявности в *C++* -- ссылки. Побитовое представление ссылки не скрыто от программиста.

Две означенные гарантии делают язык *С* нашим общим читаемым "языком ассемблера", но в то же время, они не дают нам получить перегрузку функций, методы класса, шаблоны. Для всех этих ништяков нужно манглирование, которого в *C* нет.

> Тезис Владимирова:
>  - Если взять язык *C*, убрать из него гарантию по именам, и добавить всё, что можно добавить, то получим *C++*. То есть язык *C++* - это {язык *C*} - {гарантия по именам} + {всё, что стало возможно, после отказа от гарантии по именам}.

Примера ради можно покомпилировать [mangle.c](https://github.com/tilir/cpp-graduate/blob/master/03-concrete/mangle.c) и [mangle.cc](https://github.com/tilir/cpp-graduate/blob/master/03-concrete/mangle.cc) на gcc и на g++ (clang/clang++) с нужными флагами, и пронаблюдать в файлах `.s` за изменением метки для имен функций в коде. 

Посмотрим на второй пример:

```cpp 
struct S {
  int foo(int x) __attribute__((noinline));
  /** атрибут, как я понимаю, заблокирует попытки компилятора
   *  оптимизировать код вставив инструкции её определения
   *  на месте её вызовов
   */
};

int foo(S *p, int x) { return p->foo(x); }  // в mangle.s будет _Z3fooP1Si

int foo(int x) { return x; }  // в mangle.s будет _Z3fooi

int S::foo(int x) { return x; }  // в mangle.s будет _ZN1S3fooEi
```
И то что здесь написано, мол якобы: "*в mangle.s будет так*", это совсем не означает, что на вашей машине метки функций будут выглядеть именно так. На каждой будет выглядеть по-другому. 

> А что это там в последней строке за `extern "C"` функция? 

### Linkage specifiers

В *С/C++* функции и переменные (не являющиеся методами-членами классов, объявленные в глобальном поле/некотором пространстве имён) могут быть аннотированы спецификатором линковки, которые говорят компилятору является ли эта сущность определённой в текущей трансляционной единице (т.е. текущем файле `.c`) и более нигде не может быть доступна, или может быть доступна/определена как в текущем `.c` файле, так и вне его. При объявлении в текущей компиляционной единице они пишутся до типа и (вроде-бы) до `const/volatile` квалификаторов. Всего их 2: `static` и `extern`. Первый в глазах компилятора вешает на сущность *internal linkage*, второй *external linkage*. Если явно спецификатор линковки не указан, то они специфицируются по умолчанию. Состояние линковки по умолчанию для каждого случая разное.

```cpp
// another.cc

const int a = 10;  //  то же самое, что и static const int a;
int n = 0;  // то же самое, что и external int n = 0;
void foo(int i);  // то же самое, что и extern void foo(int);
static void another_foo(int i);  // явно имеет internal linkage
```

```cpp
// main.cpp

extern const int a;  // явно имеет external linkage
static int n = 0;  // явно имеет internal linkage
void foo(int i);  // то же самое, что и extern void foo(int);
void another_foo(int i);  // то же самое, что и extern void another_foo(int);

int main () {
  int i = 5;
  another_foo(n); /* main пусть и знает про объявленное another_foo
  * но объявление выше не слинкуется с определением
  * another_foo(int) из another.cc, ведь она там "static".
  * Это ошибка компиляции*/
  foo(i);  // ok
}

и компилируем это, например, строченькой
"g++ main.cc another.cc"
```
... (здесь надо допридумать исчерпывающий пример, демонстрирующий влияние `static/extern` ключевых слов) 

> **Выводы**:
> 1. Имя может быть объявлено один раз за компиляционную единицу.
> 2. До тех пор, пока 1е выполняется, в многофайловом проекте может быть сколько угодно internal-linked-сущностей, но external-linked-сущность может быть лишь одна
> 3. Как только в модуле появляется internal-linked-сущность с конкретным именем, содержимое модуля перестаёт знать об external-linked-сущности с этим именем.
> - `const` на тип переменной помимо прочего вешает internal linkage
> - Чаще по умолчанию у объектов класс связывания внешний.

Чтобы сделать стабильный Си-шный интерфейс в коде на *C++*, т.е., например,чтобы объявить функцию, которая, уже существует в бинарном скомпилированном из кода на *C* виде внутри некоторого внешнего объектника(.o-файла), или библиотеки(.a/.so/.lib/.dll), с которой мы хотим слинковать свой код, мы вешаем на него `extern "C"` спецификатор линковки. Если это сделать, метка имени этого объекта в ассемблере не будет манглироваться компилятором *C++*. 

Само собой `extern "C"` сущность не может быть методом-членом класса, шаблоном, или объектом некоторого неглобального пространства имён, потому что ни тех, ни других, ни третьих не существует в языке *C*.

>**Маленькое замечание насчёт `extern "C"`**: поскольку linkage specifier не входит в сигнатуру, механизмы манглирования компилятора С++ не могут перегрузить обычную сущность `extern "C"`-сущностью.

```cpp
// module.cc

int foo(int x) { return x; } // в module.s будет _Z3fooi

extern "C" int foo(int x) { return x; } // в module.s было бы foo
```
Казалось бы, метки будут иметь разные имена, и конфликта не возникнет. <br/>Но увы, сделать так нельзя.

Перегрузки - это хорошо, да? <br/> Есть ли минусы у этого механизма абстракции? </br> Здесь мы плавно перетекаем в следующую тему:

 ## [Разрешение перегрузок, name resolution, overload set](https://youtu.be/TQ5VPnKWqoY?t=2990)
Минусов нет, есть нюансы, которые хорошо бы знать.

В стандартной библиотеке языка *C*, а именно в `math.h` есть функции для вычисления квадратного корня числа, сманглированные руками:

```c
// ~math.h

float sqrtf(float x);  // 1
double sqrt(double x);  // 2
```
```c
// main.c

#include <math.h>

int main() {
  ...
  sqrtf(42);  // вызовет 1, неявно преобразует int -> float
  ...
}
```

Но в *C++* с последним возникнет определённая сложность:

```cpp
// ~cmath

float sqrt(float x);  // 1
double sqrt(double x);  // 2
```
```cpp
// main.cpp

#include <cmath>

int main () {
  ...
  sqrt(42);  // неясно, что вызвать, ведь оба варианта подходят
  ...
}
```
В строчке с вызовом `sqrt(42)` компилятор должен будет **разрешить имя**, т.е. связать упомянутое в коде имя с обозначаемой этим именем сущностью. И посмотрим на это со стороны компилятора *C++*; чем вообще может быть это имя?
- вызовом функции $\Rightarrow$ понятно...
- конструктором класса $\Rightarrow$ `sqrt(42)` - это конструирование временного объекта пользовательского типа "`sqrt`"
- ...
- `typedef` для `int` типа $\Rightarrow$ `sqrt(42)` - это конструирование временного инта от 42.

Ну ок. Допустим вариантов, чем может быть *sqrt* исчерпывается первым пунктом. Тогда **name resolution process** должен закончиться выбором либо сущности *1*, либо сущности *2* из `cmath`.

> **Вопрос**: С чем свяжется `sqrt`?

>> - Ни с чем. Это ошибка компиляции. Компилятор скажет: "я не знаю, что вы имеете в виду". `int` находится одинаково далеко и от `float`, и от `double`, а именно на расстоянии в одно *неявное стандартное преобразование*.

> **Вопрос**: почему мы не можем/не хотим подключать в *C++* код legacy-хедер `math.h`? Ведь это бы частично решило выше обозначенную проблему!

>> - потому что мы не хотим засорять глобальное пространство имён. О том, что это означает, мы поговорим в конце лекции.

---
### [Порядок разрешения перегрузки функций в name resolution process]()
При вызове какой-либо функции от каких-либо аргументов происходит следующее:

- Компилятор выбирает все имена, о которых знает, в множество **candidates**, и фильтрует конкретно неподходящие; те что не подходят по составу имени, те в которые не пролезет обозначенное кол-во аргументов. Оставшиеся суть **viable candidates**, которые дерутся по следующим правилам:
1. Если есть одно точное совпадение по типам (int -> int, int -> const int&, etc), то оно побеждает.
2. Если есть два и более точных совпадений, то ошибка компиляции с выбросом всего overload-set листа с жизнеспособными кандидатами.
3. Если нет точных совпадений, но
    - есть шаблон, под который данный вызов может подстроиться, то побеждает шаблон.
    - есть много перспективных шаблонов? <- здесь нюансы, о которых пока не будем говорить
4. Если нет ни точных совпадений, ни шаблона, но
    - есть совпадение с точностью до одного неявного стандартного преобразования (`int` -> `char`, `float` -> `unsigned short`, etc), то побеждает оно.
5. Если нет ни точных совпадений, ни шаблона, ни кандидатов на расстоянии в 1 standart implicit cast, но
    - есть совпадение с точностью до возможного пользовательского преобразования (или их цепочки) через перегруженные операторы приведения типа у наших классов, то побеждает оно.
6. Если нет всех выше перечисленных, то последняя надежда на переменное число аргументов.  Определение с `var_arg`-ами, т.е. функциями с аргументами, где присутствуют многоточия (эллипсис).
7. Если ко всем прочим и вараргов нет, то побеждают кандидаты, которые подразумевает неправильную связку передаваемых аргументов с ссылками. И, это не точно, но скорее всего ничем хорошим не заканчивается. В лучшем случае ошибка компиляции.

Этот список неполный, и не отражает всех тонкостей процесса разрешения перегрузок, но пока нам его достаточно. Мы к нему ещё вернёмся, когда будем говорить о шаблонах, о правых ссылках и о пользовательских преобразованиях.

Чтобы ощутить выше перечисленный порядок на примере, можно покомпилировать [overload.cc](https://github.com/tilir/cpp-graduate/blob/master/03-concrete/overload.cc), или посмотреть, как это [сделал автор](https://youtu.be/TQ5VPnKWqoY?t=3271).

> **Вопрос**: почему переменное число аргументов стоит ниже всего?
  
>> - Вообще, эллипсисы, варарги, весь механизм реализованный в библиотеке `stdarg.h` в *C++* почти не нужен, потому что в *C++* у нас есть вариативные шаблоны (переменное число аргументов шаблона), которые, благодаря всей магии компилятора *С++* не наружают статическую типизацию и дают на выходе точно типизированную функцию, но с произвольным числом аргументов. Эллипсисы встречаются редко $\Rightarrow$ ожидаются в последнюю очередь и завершают список перегрузки. И то, что они завершают список перегрузки, чрезвычайно полезно по причине, о которой мы узнаем на лекции про *SFINAE*.

>> - "*[Технический ответ следующий](https://youtu.be/TQ5VPnKWqoY?t=3630). Когда вы используете варарги, вы много платите. Когда вы используете точные типы, вы платите мало. Варарги же усложняют ABI. `va_list`, `va_start`, `va_arg` - с точки зрения ассемблера очень дорогие вызовы. Считается, что мы до последнего не хотим платить за этот вариант разрешения имени.*"


---
## [О пространствах имён и последние 2 назначения using](https://youtu.be/TQ5VPnKWqoY?t=3869)
Очень часто мы упоминали термин *пространства имён* выше, и сейчас в кои-то веки его уточним.
Технически, это дополнительная приставка к имени для манглирования без прикосновения к типам. В любом коде, в любой его точке мы находимся внутри области какого-то пространства имён, по умолчанию - глобального. Синтаксис для уточнения означенной приставки следующий:<br/> `namespace::name`

```cpp
// no namespace here, which is global one
int x;
int foo () { return x; }
int bar () { return ::x; }
```
Функции `foo` и `bar` делают одно и то же. Просто внутри `bar` мы явно уточнили, что возвращаемое значение `x`, принадлежит переменной из глобального пространства имён. Глобальное пространство имён никак не называется, поэтому до двойных двоеточий пустота. А `foo` возвращает значение переменной `x`, которая happened to be глобальной переменной в том же пространстве имён, что и `foo`, а поскольку они оба в глобальном пространстве имён, то `foo` возвращает значение того же самого `x`, что и `bar`.

В языке *C* все сущности неизбежно находятся в глобальном пространстве имён, ведь термина "*namespace*" в *C* не существует.

В языке *C++* термин "*namespace*" появился, и в коде языка *C++* засорять глобальное пространство имён считается очень дурным тоном, ведь глобальное пространство имён одно единственное.

В общем случае все имена стандартной библиотеки языка *C++* лежат в пространстве имён `std`. В нём есть удобные динамические массивы `std::vector`, строки `std::string`, поисковое дерево `std::set` и пр. И поскольку мы не хотим засорять глобальный *namespace*, мы выбираем НЕ ПОДКЛЮЧАТЬ legacy-(`*.h`)-хедера наследованные из языка *C*, а при необходимости использовать их аналоги: `cmath`, `cstdio`, `cstdlib`...(принцип замены понятен; убираем `.h`, добавляем приставку `c..`). В них, сущности, когда-то давно определённые на *C*, занесены в `std`.

В пространство имён могут быть завёрнуты лишь те сущности, которые существуют в грамматике языка. И главное следствие этого - макроопределения всегда глобальны и не могут быть завёрнуты в неглобальное пространство имён. Поэтому "assert" - это просто `assert`, а не `std::assert`, и даже не `::assert`.

Заворачивать сущности в пространство имён просто:
```cpp
namespase MyNamespace {
  // объявление класса внутри MyNamespace
  class MyClass;

  // объявление/определение структуры внутри MyNamespace
  struct MyStruct{ /*...*/ };

  // объявление функции внутри MyNamespace
  int foo(MyStruct *obj_1, MyClass *obj_2 );
}  // <- здесь точка с запятой не нужна, в отличие от классов

int x{};  // иницализация глобальной переменной x нулём
// "value-инициализация"

// переоткрытие пространсва имён для его дополнения 
namespase MyNamespace {
  // опреледение выше объявленного класса в первом открытие MyNamespace
  class MyClass {
    // агрегация MyOtherPodclass внутрь MyClass
    class MyOtherSubclass { /*...*/ };
    static int y{};
    static void bar(int x) { /* ..y.. */ }
    /* ... */
  };

  // определение выше объявленной функции в первом открытие MyNamespace
  int foo(MyStruct *obj_1, MyClass *obj_2 ) { /*..x..*/ }
}

int main() {
  MyNamespace::MyStruct ob_1;
  MyNamespace::MyClass ob_2;

  x = MyNamespace::foo(&ob_1, &ob_2);
  MyNamespace::MyClass::bar(x);
  MyNamespace::MyClass::MyOtherSubclass ob_3;
  /* ... */
}
```

1. Заметим, что функция `main`, как точка входа программы, всегда находится в глобальном пространстве имён, сколько мы её помним. И оказывается, что по умолчанию она неявно является `extern "C"`, а значит, ни в каком другом пространстве имён, кроме глобального, она находиться не может, потому что, ещё раз, С-API не знает, что такое "пространство имён", а операционная система при запуске программы ожидает, что её точка входа находится в глобале. И по-хорошему, этикет диктует нам, что `main` - это единственная сущность, которой можно засорить глобальное пространство имён нашей программы.
2. Пространства имён можно переоткрывать сколько угодно раз, в отличие от структур и классов. И вкладывать одни в другие на какую угодно глубину.
3. В ситуации, когда некоторый класс `А` объявлен внутри другого класса `B`, `А` в отношении `B` существует, как пространство имён. Аналогичные отношения наблюдаются между классом и его `static` членами.

Ключевое слово `static` контекстно зависимое. И теперь мы можем закрыть тему о нем. 
1. В глобальной области видимости, в отношении переменных или функций `static` - это internal linkage specifier.
2. `static`-переменная объявленная внутри функции имеет время жизни до конца работы программы, не умирает по достижению границы scope этой функции, и, как и обычная локальная переменная, по имени доступна только внутри этой функции.
3. `static`-члены класса (функции, переменные) сущетсвуют в единственном экземпляре вне зависимости от того, сколько объектов этого класса было объявлено в коде (даже если ни один не объявлен). И синтаксис вызова `static`-члена класса подразумевает реферирование к нему из пространства имён с именем содержащего класса: `MyClass::bar(x);`

Очень дурным тоном в коде считается переоткрытие пространства имён `std`. Это можно делать, компилятор не будет ругаться, если всё будет написано правильно, но это игра с огнём автоматом классифицирует нашу программу как *ill-formed*, и *no diagnostics required*. Причина та же, что и у попыток именовать свои сущности с приставками нижних подчёркиваний и заглавных букв, которая тянется с языка *С*: <div style="text-align: center"><b>НЕ НУЖНО ЛЕЗТЬ И ПЫТАТЬСЯ ПРАВИТЬ ИНСТРУМЕНТАРИЙ СТАНДАРТНОЙ БИБЛИОТЕКИ</b></div>

`namespace` - это не тип. Это приставка к имени сущностей. В проектировании распределение сущностей по пространствам имён нужно для символического/смыслового отделения их друг от друга. И правило хорошего тона следуюшее:
> **Если в программе нет ни одного объекта типа, то не должно быть и типа**. То есть, нужно либо разжаловать его до пространства имён, если приставка proves to be useful, либо избавиться от этого типа вовсе (речь о пользовательских типах).

И теперь мы можем закрыть тему смыслов ключевого слова `using`.
1. Ввод шаблонных псевдонимов. Перегрузка функционала `typedef`. 
```cpp
template <typename T>
using vector = std::vector<T>;
/** и теперь везде, где мы напишем vector<type>
 * оно будет означать std::vector<type> */
```

2. Внос сущности в текущее пространство имён:
```cpp
namespace MyNamespace {
  using std::vector;
}  /** означает "зайди в std, найди там сущность vector 
  *  и сделай эту сущность местной внутри MyNamespace".
  * Вместо MyNamespace могло быть и глобальное пространство имён. 
  * И теперь внутри MyNamespace не нужно писать std::,
  * чтобы объявить std::vector. */
```
3. Внос всех сущностей данного пространства имён в текущее // удар молотком по темечку :3

```cpp
namespace MyOtherNamespace {
  using namespace MyNamespace;
} /** означает, что внутри MyOtherNamespace 
  * все имена из MyNamespace будут доступны без приставки.
  * Вместо MyOtherNamespace могло быть и глобальное пространство имён. */
```  
> **Вопрос**: почему `using namespace std;` - это плохо?
>> Да, нам больше не надо писать `std::` при частых обращениях к сущностям из стандартной библиотеки, НО если мы делаем это в нашем пространстве имён, наименования наших сущностей может начать конфликтовать с именами из `std`. Есть ещё причины...

> **Вопрос**: идиома `using namespace` распространяет своё влияние только внутри пространства имён, в котором была произнесена, или же её действие можно распространить на что-то локальное, например scope функции?

...

---
### [Анонимные пространства имён](https://youtu.be/TQ5VPnKWqoY?t=4269)
That is some strange russian term, if I've ever heard one, чё.

Как это? Вот к примеру такой код.
```cpp
namespace {
  int foo() {return 42;}
}
int bar () { return foo(); }  // ok.
```
Компилятор сделает с этим кодом следующее:
```cpp
namespace Idsghes2iHWAcM6id {
  int foo() {return 42;}
}
using namespace Idsghes2iHWAcM6id;
int bar () { return foo(); }
```
Переводим.<br/> **Анонимный namespace** означает: "*сделай `namespace` с бессмысленным, сложным и уникальным именем, и по его закрытию сделай его `using`*".

> **Вопрос**: зачем это может быть нужно?
>> Все сущности внутри анонимного `namespace` будут известны только внутри текущего модуля, ведь сгенерированное имя является случайным, уникальным, а главное, недостижимым, его нигде не посмотришь. То есть, это *C++*-способ навесить *internal linkage* на все сущности внутри него без использования `static`-спецификатора линковки.

Таким образом анонимные пространства имён - это помошники в инкапсуляции внутри модуля. И с анонимными пространствами имён мы почти не используем ключевое слово `static` для внутренней линковки сущностей.

Правила хорошего тона использования ключевого слова `namespace` следующие:
- **Не засорять глобальное пространство имён ничем, кроме `main`.** Потому что оно у нас одно.
- **Никогда не писать `using namespace` в хедерах.** Потому что если заголовочные файлы подключаются в какие-то разные файлы реализации, где в одном популяризация имён распространяемого через `using` нужна, а в другом не нужна и даже мешает, ведь имена в этом файле реализации конфликтуют с именами из рапространенного `namespace`, тогда таким хедером просто будет неудобно пользоваться.
- **Использовать анонимные пространства имён для внутренней линковки сущностей в модуле.** Потому что мы пишем на *C++*, а не на *C*.
- **Не использовать анонимные пространства имён в заголовочных файлах.** Потому что генерация случайного имени происходит один раз на единицу трансляции. То есть, если мы в несколько модулей подключим хедер с анонимным пространством имён, то каждый из этих модулей понесёт на себе namespace с уникальным именем, но одними и теми же функциями, что существенно раздует код $\Rightarrow$ бинарь...

С учётом всего выше сказанного, вот так выглядит кошерный *C++*-код для helloworld-программы:

```cpp
#include <iostream>
namespace {
  char const * const hw_str = "Hello, world"; 
}

int main () {
  std::cout << hw_str << std::endl;
}
/**
 * 1. мы не сэкономили на std::
 * 2. мы не засорили глобальное пространство имён идентификатором hw_str
 *  (не то что бы он был вообще нужен, но здесь он скорее для выебона)
*/
```
