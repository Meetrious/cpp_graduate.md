# Лекция 3 (Имена и сущности)

## Контекст
В прошлой лекции говорилось о такой штуке, как контекст в разных представлениях.
- Модуль в языке *С* - это контекст. <- (здесь под модулем подразумевается отдельная компиляционная единица, быть может без точки входа)
- Даже ф-ция тоже по своему является контекстом в себе.
- В языке *C++* класс - это контекст.

Контекст в том смысле, что может инкапсулировать в себе данные.

- Статическая глобальная переменная, которая объявлена и определена в отдельном модуле кода на *C* **не видна** никому за пределами этого модуля.
- Статическая переменная, объявленная внутри ф-ции, **не видна** никому, кроме этой ф-ции.
- Приватный член класса **защищён от доступа по имени** со стороны внешних функций и методов наследующих классов.

В последнем никакой речи о сокрытии данных не идёт. Мы ничего не можем скрыть в *C++*, потому что мы живём в виртуальной памяти, где всё на виду. При большом желании можно привести указатель на объект к `(char*)` и, шагая по адресам адресной арифметикой, подступиться к приватным внутренностям объекта и изменить их.

Означенное сокрытие that is **защита от доступа по имени** - это механизм абстракции, который очень важен и позволяет нам сохранять инварианты класса.

Инвариант класса - это что-то, что не контролируется нормативными документами языка, но что в языке присутствует с учётом контекста решаемой задачи.

- Полигон "знает", что все его вершины отсортированы по кругу и что он выпуклый.
- Список "знает", что в нём нет петли.

"Знает" означает, что утверждение выполняется на всём продолжении жизни объекта.

Ну так вот. Старые добрые `malloc` и `free` ничего не знают о конструкторах и деструкторах. В том смысле, что протяжении их работы, никаких утверждений относительно необходимости, или отсутствия необходимости, вызова каких-то доп. ф-ций, работающих надо объектами, нет.

Поэтому, если есть класс с нетривиальным конструктором, или даже с конструктором по умолчанию (без аргументов), который некоторым образом задаёт начальное состояние объекта, и нам вздумается создать этот объект, или массив этих объектов, через `malloc`. Что мы получим?

> - `malloc` вернёт void указатель на объект, на который OS выделила память на куче. И сам объект будет инициализирован мусором. Никакой конструктор не будет вызван.

Инициализация объекта в неконсистентном состоянии нас не устраивает по понятным причинам. Нам нужен `malloc`, который бы знал о пользовательских типах в *C++*. То есть о тех, у которых при инициализации надо вызывать конструкторы.

---

## new и delete

В *C++* аллокация делается через `new` и `delete`. Они вызывают конструкторы и деструкторы создаваемых/удаляемых объектов соответственно. Более того мы заводим 2 варианта `new` и 2 варианта `delete`. Один комплект для одиночных объектов, другой - для массивов.

``` cpp
int *t = new int;
delete t;

int *p = new int[5]
delete [] p;
```
> **Вопрос**: Зачем их две, если `malloc` был только один?

Чтобы на него ответить, зададим

> **Другой вопрос**: а откуда `free` вообще знает, сколько освобождать? Ведь у `free` всего лишь один аргумент - указатель, память по которому надо освободить. Однако же через `malloc` можно выделить сколько угодно "байт" памяти, и `free` по полученному указателю освобождает и не ошибается в кол-ве.

Вспомним сигнатуру `malloc`:
```c
void* malloc(size_t size);  // size_t - это typedef для unsigned long
```
Т.е. `malloc` возвращает указатель на адрес в памяти, по которому ОС выделила динамической памяти в кол-ве `size`-шт. местных чаров.

И оказывается, что в позиции левее (т.е. ближе к `NULL`) от расположения первого элемента выделяется место в памяти, в которое складируется значение кол-ва байт, которое ф-ция `free` должна будет освободить.

Теперь мы можем ответить на первый вопрос.
>> - Затем, что оператор `delete` не читает (как оптимально с его стороны), сколько надо удалять перед удалением. А оператор `delete []` таки читает. Равно как и `new` не пишет напоминалку "сколько выделил", тогда как `new type[]` пишет.

В общем случае, если перепутать `free`, `delete` и `delete []`, следует ожидать UB и потому парность вызовов `<malloc, free>`, `<new type, delete>`, `<new type[], delete []>` относительно одного ресурса нарушать нельзя.

Единственный инструмент для гарантии того, что мы случайно не перепутаем вызовы - инкапсуляция. Вызываем нужные аллокаторы в конструкторах, нужных освободителей в деструкторах.

Для наглядности можно покомпилировать и заексплорить в gdb пример [newdelete.cc](https://github.com/tilir/cpp-graduate/blob/master/02-lrefs/newdelete.cc).

---

## Провисание ссылок

Пусть есть ситуация в `main`:

```cpp
int *iarr = new int[5];
int &r = iarr[2];
// .. smth
delete [] iarr;
```
> **Вопроc**: Что после всего этого стало с ссылкой `r`?

>> - говорят, что она "***провисла***". На английском это состояние звучит, как "***dangling***". Это означает, что ссылка(для указателей это состояние эссенциально в той же мере) связана с объектом, чьё "*время жизни*" закончилось.

***Время жизни*** переменной в *С/С++* - это совокупность всех моментов времени исполнения программы, в которых состояние этой переменной **валидно**. Т.е. в любой из моментов времени жизни переменной у процесса нашей программы есть доступ к её области памяти и ОС гарантирует, что никакой другой процесс эту память себе не заберёт (может расшарить, если она аннотирована ключевым словом `volatile`, но в личное безраздельное пользование не заберёт).

Естественный ограничитель времени жизни переменных в памяти <u>на стеке</u> - границы **области видимости** (*scope*). Они нам известны, как наиболее встречающие случаи фигурных скобок.

***Scope*** переменной - это совокупность мест в коде программы, откуда можно обратиться к объекту по имени.

```cpp
int a = 2;  // scope переменной a глобальный. К этой переменной
// есть доступ у любого подблока (будь то ф-ция, класс...)
// внутри текущего модуля.

void foo() {
  int b = a + 3;  // для инициализации b используется значение a.
  // foo находится внутри области видимости a.

  if (b > 5) {
    int c = (a + b) / 2;  // if конструкция находится внутри 
    // области видимости переменных a и b.
  }

  b += c;  // область видимости c закончилось.
  // Здесь попытка переопределения b через значение по имени,
  // которое более недоступно. Ошибка компиляции.
}
```
Имя переменной вводится в *scope* в точке её объявления (point of declaration). И обычно эта точка находится в позиции, ПОСЛЕ того, как прозвучали тип и имя, и ДО первого инициализатора (до присваивающего равно, или скобочек аргументов конструктора). Время жизни переменной начинается по окончанию последнего инициализатора. Следующий пример очень редок и демонстрирует, как можно воспользоваться чем-то до рождения этого чего-то.

```cpp
int main() {
  int a = a;  // это не ошибка компиляции. Это UB
  ...
}
```

И это редкий/достаточно детский способ выстрелить в ногу, от которого отучиваются компиляцией с флагом `-Wall`, или `-Wextra`, когда учатся писать на *C*. Отучиваются с помощью правила: "явно инициализировать чем-нибудь конкретным и дефолтным переменные СРАЗУ после объявления".

Время жизни объектов выделенных <u>на куче</u> же умеют переживать окончание scope имён с ними связанных, и потому необходимо не забывать освобождать их руками.

На самом деле куда более частая ошибка -- использовать нечто, уже после смерти этого нечто. И вот мы обратно вернулись к провисанию ссылок/указателей.

Перечислим классические примеры провисания ссылок/указателей:

Уже знакомый:
```cpp
int a = 2;
void foo() {
  int b = a + 3; int *pc = nullptr;
  if (b > 5) {
    int c = (a + b) / 2; pc = &c
  }  // время жизни переменной с, как и её область видимости здесь кончается.

  b += *pc;  // указатель pc всё ещё указывает на область памяти переменной,
  // которая уже умерла. Указатель pc "провис". "Попугай умер".
}
```

Теперь про тот, что был вначале темы:
```cpp
int *iarr = new int[5];
int &r = iarr[2];
// .. smth
delete [] iarr;  // ссылка r "провисла"

// и сама по себе провисшая ссылка - это не страшно.

// страшно, когда мы начинаем её использовать, и что-то с ней делать
r += 1;  // "бытие попугая исчерпано". 
// То на что ссылается r больше не принадлежит этому процессу этой программы.
```

Другой популярный пример:
```cpp
int& foo() {
  int x = 42;
  return x;  // здесь значение x не скопируется никуда.
  // Но возващаемый int& свяжется именно с этим умирающим в return объектом x.
}

int main() {
  int x = foo();  // "попугай почил и протух" в момент смерти int x в foo.

  // компилятор эту хрень даже не заметит. 
  // Дай Бог если статический анализатор предупредит об этой ошибке.
}
```
Пример выше будет в той же степени провальным, если заменить сигнатуру внешней ф-ции `int& foo()` на `const int& foo()`. Да, мы говорили на прошлой лекции, что константные ссылки умеют продлевать время жизни временных объектов, но это не тот случай. Здесь никакого второго имени, или изобретения первого имени для выходного `x` не произойдёт, и `const int&` провиснет так же, как и `int&`.

> **Закономерный вопрос**:  А какой тогда вообще смысл возвращать `type&`, если внутри всё умрёт и нельзя ничего спасти.

>> - возвращаемый аргумент `type&` ф-ции может в целости вернуть ссылку на глобальную переменную, и на переменную в динамической памяти.

```cpp
int foo();  // из предыдущего примера

main {
  const int& lx = 0;
  int x = lx;  // это ок.
  
  const int &ly = 42 + foo();  // 
  int y = ly;  // тоже ок.

  // но если возвращаемый int в foo заменить на сonst int&,
  // или на int&, то ly провиснет.
}
```

Выучим полезное правило про временные объекты:
> ***Временный объект живёт до конца полного выражения!***

Не совсем понятно, что есть "полное выражение" (для меня это синтаксически корректная инструкция, заканчивающаяся "`;`"). Но полезный пример в связи с этим правилом следующий:

```cpp
struct S {
  int x;
  const int& y;
}

main {
  S obj1 = {1,2};  // произошла агрегатная инициализация, всё ок.
  // Жизнь временного объекта "2" будет продлена на стековом фрейме,
  // в котором был создан obj1

  // А теперь сделаем очень похожую вещь, только в куче:
  S *ptr = new S{1,2};  /* безымянный S{1,2} - это временный объект 
  (можно сказать "референс для конструирования объекта" для new), 
  который попадёт в new, и последний попытается выделить
  память в куче для нового объекта типа S и свяжет
  "const int& y" c временным объектом 2 в безымянном S{1,2}.
  После этого выделения безымянный объект S{1,2} умрёт
  и временный "2" вместе с ним.
  new вернёт указатель на выделенный объект в ptr.
  Однако второе поле этого объекта будет невалидно.
  ptr->y провиснет, ведь "2" умерла вместе с S{1,2}. */
}
```

Другой полезный урок, который предоставляет этот пример, следующий:

> ***Не надо использовать членов-ссылок в классах!***

Ну то есть никто не запрещает. Это можно делать, но только если это хорошо обосновано, что, видимо, редкость.

К счастью модифицируемые левые ссылки не связываются с временными объектами (r-value выражениями) и не продлевают им жизнь. И любую попытку связать компилятор отловит.

```cpp
int foo();
foo(1);  // ошибка компиляции

int &x = 1;  // ошибка компиляции.
```
> **Cпойлер**:<br/>
>! c r-value выражениями свяжутся модифицируемые правые ссылки. Но о них позже.

Сформулируем небольшое полезное наставление:

> ***К левым ссылкам надо относиться как к пластиковым стаканчикам. Пока мы берём их и используем - это безопасно, годно. А вот хранить, а уж тем более возвращать их после использования кому-то куда-то - скорее не вежливо, а в нашем контексте небезопасно.***

---

Поговорим про l-value ещё чуть-чуть.

## Decay (разложение, увядание, или деградирование) и l-values

Глянем на пример:

```cpp
int foo(const int & t) {
  return t;  // Что может быть бесполезнее?
}
```
Внутри `foo` мы относимся к переменной `t`, как к `int`-переменной (в смысле синтаксиса для её использования). Хотя на самом деле нам уже известно, что `t` - это гораздо более сложная штука в отличие от привычного `int`-объекта. Мы знаем что на самом деле `t` - это скорее разыменнованный указатель на реально существующий `int`-объект, находящийся в стековом фрейме некоторой ф-ции, в контексте которой по стечению обстоятельств была вызвана ф-ция `foo`. 

И вот это явление упрощения интерфейса над конкретным объектом (чей финальный интерфейс был более сложным) в контексте какого-нибудь блока (ф-ции, класса) называется ***decaying***.

Скорее более очевидным примером "увядания, или разложения, или деградирования" является передача объекта в функцию по аргументу, тип которого суть базовый класс для класса передаваемого объекта (через такое действие осуществляется динамический полиморфизм, и мы поговорим о том, что это означает, позже).

Другой пример, куда ближе, но слабее, который встречается даже в *C* - это имя массива.
```c
void foo(int);

main {
  int arr[5];
  int *t = arr + 3;  // ok
  foo(arr);  // ok
  arr = t  // fail
}
```
Имя `arr` - это не только имя массива. В сущности `arr` так же является именем указателя на первый элемент этого массива. Последняя интерпретация проще первой. 

> **Отвлечение**: Ну и да. `arr` сам по себе на самом деле не имеет тип `int*`. Поскольку этот `arr`-указатель нельзя подвинуть, то к нему в некоторой степени можно относиться как к объекту типа `int * const`.

При этом `arr` является вполне себе *l-value*, ведь оно имеет место в памяти, но учитывая его константность мы не можем его поставить слева от равенства в инструкции.

И вот мы неуклюже переключаемся на тему l-value. 

---

### left or location?

Надо понимать, что *r-value* и *l-value* - это не какое-то там свойство, или характеристика для переменных. **Это характеристика выражений**. В *С* концепция l-value означала left-hand-side value, т.е. то, что стоит от равенства слева. 

Одно из самых мистических выражений в *C*, это следующее:
```c
y = x;
```
И мистическое оно потому, что равенство в этом выражении вообще не симметрично, ибо оно означает скорее `y := x`. Равенство здесь не предикат, а операция присваивания. В этой связи от `x` требуется, чтобы это было какое-то подходящее для типа переменной `y` значение. А от `y` требуется, чтобы оно имело место в памяти, обращение по имени `у` к которому позволяло её модификацию. Т.е `y` здесь - это как разыменованный `nonconst`-указатель на место в памяти, к которому у процесса этой программы есть доступ.

Требования на `y` совершенно иные, по сравнению с требованиями на `x` в этой инструкции. И в *С*, в контексте этой инструкции, `y` - это *l-value*, а `x` - это *r-value*.

Вообще, результат вызова любой ф-ции в *С* является r-value выражением (да, действительно. На указателях я тоже проверял)

В *C++* же ф-ция может стоять слева от знака `=`. Потому что в *C++* появились левые ссылки. И ф-ции в коде на *C++* могут эти левые ссылки возвращать.

```cpp
int& foo();  // имеет смысл только если foo возвращает ссылку
//  на глобальную переменную, или
//  на динамически-аллоцированную внутри foo память.
foo() = x;  // это ок.
```

В связи с этим в *C++* в обозначении *l-value*, ***l*** стоит не за *left-hand-side*, а за ***location***. И в отношении инструкций вокруг знака `=` *l-value* означает, что: "*выражение, у которого есть адрес*".

В *C++11* появился более широкий термин: *generalised l-value*, или *gl-value*, который объединяет l-value-выражения c выражениями, которые имеют временное положение в памяти. И да, множество r-value выражений пересекается с множеством gl-value выражений. Об этих классификациях мы поговорим, когда доберёмся до r-value.

---

## Cdecl и как замотивировать typedef в *C* и using в *C++*

Зайдём со стороны ссылок/указателей на массив.
Вот есть объявления для двух объектов:
```cpp
int *x[20];
int (*y)[20];
```
> **Вопрос** :Чем являются эти объекты?

Чтобы уметь на него отвечать, надо уметь читать *си-выражения*, или *c-declarations*, или *cdecl* \[сидекл\]. Техника очень простая:
1. Находим имя, которое не является ключевым словом языка.
2. Произносим всё, что стоит правее имени, пока не уткнёмся в `)` или в `;`.
3. Утунулись. Произносим всё, что стоит левее имени, пока не уткнёмся в `(`, или в конец текущего выражения.
4. Уткнулись в `(` $\Rightarrow$ выходим из скобок.
5. Повторяем процесс с пункта 2, только теперь не в отношении имени, найденном в самом начале, а в отношении содержимого скобок, из которых вышли на предыдущем шаге. Повторяем, пока не прочитаем выражение до конца.

Первая строка читается:

x - это (\*идём вправо, видим `[20]`, говорим\*) массив из 20ти  (\*уткнулись в "`;`", идём влево от `х`, видим "`*`", говорим\*) указателей на 
  (\*идём влево дальше, видим "`int`", говорим\*) `int`.

Итого в первой строке объявлен *`x`, который является массивом из 20 указателей на переменные типа `int`.*

Во второй: *`y` суть указатель на массив из 20 элементов на `int`.*

> **Вопрос**: а в чём разница между `x` и `y`.

```cpp
int *x[20];  // массив из указателей
int (*y)[20];  // указатель на массив

x[1] == *(x + 1) == *(int**)((char*)x + 1 * sizeof(int*))
- это значение в первом указателе из массива x.
  (т.е. это один из 20ти адресов, по которому лежит некоторый int,
    а не какой-то там int сам по себе)


y[1] == *(y + 1) == *(int**)((char*)y + 1 * sizeof(int*[20])) 
- это указатель на следующий объект типа int[20]
  (т.е. указатель на следующий массив из 20ти элементов после текущего)
  (т.е. указатель на ячейку, в которой лежит 
        адрес первого (т.е. нулевого) элемента следующего int[20])
```
>> - Разница в том, как для них работает адресная арифметика.

В этом можно убедиться поиграв с примером на [godbolt](https://godbolt.org/z/EKG7vsnhP).

Пусть факт и не удивительный, но заметим, что ссылки на массив можно брать:
```cpp
int (*y)[20];  // указатель на массив
int (&z)[20] = *y;  // ссылка на массив

z - это адрес первого(т.е. нулевого) элемента текущего int[20].
```
Ну и ладно. Перейдём к чему-нибуть более проклятому.

```cpp
// здесь отправной объект называется "c"
char *(*(&c)[10])(int *&p);
/** c - это ссылка на массив из 10 указателей на ф-цию,
 * принимающую ссылку на указатель на переменную int, и
 * возвращающую указатель на переменную char. */

// здесь отправной объект называется "bar"
void (*bar(int x, void(*func)(int&))) (int&);
/** bar - это функция, которая принимает два аргумента x и func (о них позже) и
 * возвращает указатель на функцию, 
 *    принимающую ссылку на int, и ничего не возвращающую.
 *
 * В свою очередь bar принимает переменную int и указатель на ф-цию func,
 *    которая принимает ссылку на int и ничего не возвращает. */
```
Всё это читать мерзко, но в финале, когда получается понять, то приятно.
Однако, не стоит извращаться; умение читать сложный *cdecl* не означает, что его надо уметь/тренироваться писать. Сложность конструкций должна быть очень хорошо обоснована, и в *C* она порой да.

Заметим, что `bar` принимает в себя вторым аргументом объект того же типа, что и возвращает.
`bar` - это ф-ция, которая принимает `int` и `void(*)(int&)`, и возвращает в точности `void(*)(int&)`. В языке *С* с подобной милотой боролись, используя **`typedef`**.

> **`typedef`** -- это ключевое слово в *C* для ввода в синтаксис нашего кода пользовательских псевдонимов для существующих типов.

Примеры:
```cpp
size_t - псевдоним для типа индексации массивов
        который на самом деле unsigned long.
typedef unsigned long size_t; /* <- именно так он определяется в
        хедерах стандартной библиотеки. */
```
И указатель на ф-цию - это тоже вполне себе тип. И оказывается, чтобы его typedef-нуть в *C*, мы не сначала пишем тип, и потом, как его обозвать, а по-другому:

```cpp
typedef void (*ptr_to_fref_t)(int&);  /* теперь ptr_to_fref_t - это псевдоним
        для типа "указатель на ф-цию берущую int& и возвращающую ничего". */
```

Теперь мы можем написать определение ф-ции `bar` понятным образом без её обёрки в тип, который она возвращает.

```cpp
void (*bar(int x, void(*func)(int&))) (int&);  // было ужастно
ptr_to_fref bar(int x, ptr_to_fref_t func);  // стало прекрасно
```

В *С* нет шаблонов. А `typedef` из `С`. Значит `typedef` не умеет в шаблонные псевдонимы. Для этих целей (и ещё парочку других) в *C++* было определено ключевое слово **`using`**.

> **`using`** -- это ключевое слово в *C++*, суть которого та же, что и у `typedef`, только он чуть удобнее и умеет немного больше, чем последний.

Используя `using` можно переписать выше описанный `typedef` следующим образом:

```cpp
typedef void (*ptr_to_fref_t)(int&);  // было в Си
using void (*)(int&) = ptr_to_fref_t;  // стало в С++
```
Т.е. с `typedef` нам нужно было зарываться внутрь выражения, чтобы понять, что же именно typedef-нуто. С `using` всё проще. По левую сторону от знака `=` стоит имя. По правую - имя чего. Строго. Понятно.

Более того, если вдруг вместо `int`-аргумента нас интересует шаблон, то `using` позволит нам его ввести, и создать целое семейство типов под нашим псевдонимом:

```cpp
template <typename T>
using void (*)(T&) = ptr_to_fref_t;

// в частности можем объявить выше упомянутый bar
ptr_to_fref_t<int> bar(int x, ptr_to_fref_t<int> func);
```

---
## Манглирование - то без чего *C++* остался бы *C*

В `string.h`-хедере *C* объявлена функция, которая умеет в строке `const char* haystack` искать первое вхождение подстроки, совпадающей со строкой `const char* needle` и возвращать указатель на первую букву этого первого вхождения `needle` внутри `haystack`. Называется эта функция `strstr`:
```c
char* strstr(const char *haystack, const char *needle); 
```
> ***Вопрос***: Почему оба аргумента `const`, а результат `nonconst`? Ладно, пофиг даже на `needle`. Почему указатель на `haystack`, принимается константный, а возвращаемый аргумент - это неконстантный из этой же строки??

>> - для обоих объектов ответ похожий: 
>>    * Если `haystack` будет неконстантным указателем на строку, то в него не пролезут константные указатели на строки.
>>    * Если `return`-аргумент будет константным указателем на строку, то мы не сможем приравнять его к объекту `char*` на выходе из `strstr`.

Другой довод для входных аргументов такой, что мол "аннотируя их `const`, автор `strstr`-ф-ции нам "вежливо обещает" не изменять содержимое этих строк." Что приятно, и тоже разумный ответ.

Но тот ответ, что выделен, куда более весомый. 

И ситуация, якобы, омерзительная. И в связи с ней мы бы хотели, чтобы было две ф-ции `strstr`:
```c
char* strstr(char *haystack, const char *needle);
const char* strstr(const char *haystack, const char *needle);  
```
И чтобы компилятор по типу принимающей результат `strstr` переменной, и по типу переменной, входящей в `haystack` вызывал ту или другую.

Увы, <u>в *C* нельзя переопределять ф-ции</u>. Но в *C++* стало можно. В хедере `cstring` она перегружена выше описанным образом. И в коде на *C++* константность первого аргумента `strstr` правильно согласована с константностью результата.

С ф-цией `sqrt` из `math.h` та же история. Там у нас объявлены
- `sqrt` для корня из `double`;
- `sqrtl` для корня из `long double`;
- `sqrtf` для корня из `float`. 

И ИМХО вот это куда более омерзительно, чем то, что нам хватило лишь одного инстанса описания `strstr`, но да ладно. В `cmath`-библиотеке языка *C++* она три раза перегружена для разных типов.

В *C* нельзя нельзя перегружать ф-ции по одной очень хорошей причине. Более того эта причина делает язык *C* до сих пор живым. Т.е. язык *C* до сих пор жив только потому, что в *С* отсутствиет механизм, позволяющий, в частности, перегружать ф-ции. Механизм, о котором идёт речь, называется **манглирование**.

> **Манглирование** - это (не дам строгого определения) механизм компиляторов С++ для искажения имён объектов в нашем коде при трансляции в ассемблер. 

Искажение хитрое, и по крайней мере для имён функций из глобала, их метка в ассемблере искажается в связи с их сигнатурой. Метка на выходе представляет из себя странное, но уникальное имя, в котором проглядывается исходное, а по бокам какой-то невнятный мусор, суть которого - некоторым образом закодированная сигнатура. 

Манглирование позволяет нам написать сколько угодно одинаково называющихся ф-ций, и до тех пор, пока
- их сигнатуры отличаются,
- и/или они разположены в разных классах,
- и/или они находятся в разных пространствах имён (о последних конце этой лекции),

их метка в ассемблере будет для каждой уникальна, а значит операционная система не перепутает какую и для чего вызвать.

В *C* нет манглирования. Если мы пишем в коде языка *C* какое-то имя, компиляторы языка *C* гарантируют, что в ассемблере это имя не будет искажено типом/типами, с которыми это имя связано. То есть язык *C* предоставляет нам гарантию по именам, что делает возможным общение других языков через его API. 

> ~*"Отсутствие манглирования означает стабильное API и стабильный ABI. Если, например, мы хотим на Python взаимодествовать с чем-то из C++, мы делаем на обоих С-интерфейс, т.к. С-интерфейс - это наш highest readable common level, читаемый ассемблер, место, где мы уверены, что на бинарном уровне у нас будут одинаковые имена и в языках они слинкуются. Даже из двух разных компиляторов С++ для одной и той же ф-ции могут получаться разные имена в ассемблере. Тупо взяли 2 модуля своей программы, один пропустили через clang++, другой пропустили через g++, они не слинкуются, если между ними нет С-интерфейса"*. 

Другая гарантия, которую даёт язык *C* - это то, что в *C* нет ничего неявного.
> Дальше идёт какой-то очень мутный пример каста ссылок (45:29).

Две означенные гарантии делают язык *С* нашим общим читаемым "языком ассемблера", но в то же время, они не дают нам получить перегрузку функций, методы класса, шаблоны. Для всех этих ништяков нужно манглирование, которого в *C* нет.

> Тезис Владимирова:
>  - Если взять язык *C*, убрать из него гарантию по именам, и добавить всё, что можно добавить, то получим *C++*. То есть язык *C++* - это {язык *C*} - {гарантия по именам} + {всё, что стало возможно, после отказа от гарантии по именам}.

Примера ради можно покомпилировать [mangle.c](https://github.com/tilir/cpp-graduate/blob/master/03-concrete/mangle.c) и [mangle.cc](https://github.com/tilir/cpp-graduate/blob/master/03-concrete/mangle.cc) на gcc и на g++ (clang/clang++) с нужными флагами, и пронаблюдать в файлах `.s` за изменением метки для имен функций в коде. 

Посмотрим на второй пример:

```cpp 
struct S {
  int foo(int) __attribute__((noinline));
};

int foo(S *p, int x) { return p->foo(x); }  // в mangle.s будет _Z3fooP1Si

int foo(int x) { return x; }  // в mangle.s будет _Z3fooi

int S::foo(int x) { return x; }  // в mangle.s будет _ZN1S3fooEi

extern "C" int bar(int x) { return x; }  // bar (can not overload foo!)
```
И то что здесь написано, мол якобы: "*в mangle.s будет так*", это совсем не означает, что на вашей машине метки функций будут выглядеть именно так. На каждой другой будет выглядеть по-другому. 

> А что это там в последней строке за `extern "C"`? 

### Linkage specifiers

В *С/C++* ф-ции и переменные (не являющиеся методами-членами классов, объявленные в глобальном поле/некотором пространстве имён) могут быть аннотированы спецификатором линковки, которые говорят компилятору является ли эта сущность определённой в текущей трансляционной единице(т.е. текущем файле `.c`) и более нигде не может быть доступна, или может быть доступна/определена как в текущем `.c` файле, так и вне его. При объявлении в текущей компиляционной единице они пишутся до типа и (вроде-бы) до `const/volatile` квалификаторов. Всего их 2: `static` и `extern`. Первый в глазах компилятора вешает на сущность *internal linkage*, второй *external linkage*. Если явно спецификатор линковки не указан, то они специфицируются по умолчанию. Состояние линковки по умолчанию для каждого случая разное.

```cpp
// another.cc

const int a = 10;  //  то же самое, что и static const int a;
int n = 0;  // то же самое, что и external int n = 0;
void foo(int i);  // то же самое, что и extern void foo(int);
static void another_foo(int i);  // явно имеет internal linkage
```

```cpp
// main.cpp
extern const int a;  // явно имеет external linkage
static int n = 0;  // явно имеет internal linkage
void foo(int i);  // то же самое, что и extern void foo(int);
void another_foo(int i);  // то же самое, что и extern void another_foo(int);

int main () {
  int i = 5;
  another_foo(n); /* main пусть и знает про объявленное another_foo
  * но объявление выше не слинкуется с определением
  * another_foo(int) из another.cc, ведь она там "static".
  * Это ошибка компиляции*/
  foo(i);  // ok
}

и компилируем это, например, строченькой
"g++ main.cc another.cc"
```
> **Выводы**:
> - `const` на тип переменной помимо прочего вешает internal linkage
> - Чаще по умолчанию у объектов класс связывания внешний.

... (здесь надо допридумать исчерпывающий пример, демонстрирующий влияние `static/extern` ключевых слов) 

 Чтобы сделать стабильный Си-шный интерфейс в коде на *C++*, т.е., например, объявить ф-цию, которая, уже существует в бинарном скомпилированном виде внутри некоторого внешнего объектника(.o-файла), или библиотеки(.a/.so/.lib/.dll), с которой мы хотим слинковать свой код, мы вешаем на него `extern "C"` спецификатор линковки. Если это сделать, метка имени этого объекта в ассемблере не будет манглироваться. Само собой `extern "C"` сущность не может быть методом-членом класса, шаблоном, или объектом некоторого неглобального пространства имён, потому что ни тех, ни других, ни третьих не существует в языке *C*.

 Перегрузки - это хорошо, да? <br/> Есть ли минусы у этого механизма обстракции? </br> Здесь мы плавно перетекаем в следующую тему:

 ## Разрешение перегрузок, name resolution, overload set.