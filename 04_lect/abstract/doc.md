# [Лекция 4 (Инициализация и копирование)](https://youtu.be/duDyVgMFyug)
Эта лекция в основном про конструкторы. И чтобы смотивировать теорию про них, мы для начала поговорим о ***сбалансированных поисковых деревьях***.

## [Поисковые деревья](https://youtu.be/duDyVgMFyug?t=33)
Напомним. Это структура данных, представляющая из себя граф, в которой объекты связаны между собой через отношения "*родитель/больше/меньше*". Из объектов выделяется *корень* тем, что он без родителя, и *листья* тем, что они без правых и левых предков. Отношение "больше/меньше" может быть задано в каком угодно фиксированном смысле (числовом, лексико-графическом и др..). Эта структура данных характеризуется свойством *поисковости*. И инвариант, который гарантирует это свойство, следующий:

>*Инвариант поисковости*: <div style="text-align: center"><b><i>Любой потомок левого потомка меньше любого потомка правого потомка.</i></b></div>


Поисковое дерево          |  Не поисковое дерево
:------------------------:|:-------------------------:
![](imgs/tree_exmpl.png)  | ![](imgs/notatree_exmpl.png)


У этой структуры данных есть параметр "*высота*" -- наибольшее кол-во узлов от корня до листа. <br/> В примере выше высота = 4.

Любой ключ может быть найден начиная от верхушки дерева за время пропорциональное его высоте. И в самом лучшем случае дерево имеет высоту $\approx log_2(\text{кол-во элементов дерева = N})$. И это делает поисковое дерево лучше, чем список/массив, в которых искать элементы придётся за $O(N)$ время.

> **Важное наблюдение**: <br/> Над одним и тем же множеством элементов все возможные поисковые деревья сохраняют его *inorder*-обход сортированным.

Это означает, что осуществив обход поискового дерева слева направо через корень, а из правого листа на корень корня и т.д., элементы будут попадаться в сортированном по возрастанию порядке. В частности *inorder*-обход может использоваться для тестирование бинарного дерева на инвариант поисковости.

К поисковым деревьям очень легко делать *range-based-queries*, т.е. запросы на диапазон в линейном порядке (например запрос "*посчитать сколько элементов между значением A и значением B*", где A и B могут и не являться элементами дерева). Что очень выгодно отличает их от *хэш-таблиц* например, ведь в последних никакой информации о соотношениях между элементами нет, а в поисковых деревьях - есть, и вполне себе конкретная.

Допустим надо реализовать минимальную реализацию дерева с возможностью добавления узла из `stdin`. Например по сигналу *`k`* принимается элемент с `double`-значением и записывается в дерево. По сигналу *`q`* - принимаются `double`-границы (первая меньше второй), по которым осуществляется *range-query*.

> **Ввод**: `k`10 &nbsp; `k` 20 &nbsp; `q` 8 31 &nbsp; `q` 6 9 &nbsp; `k` 30 &nbsp; `k` 40 &nbsp; `q` 15 40<br/>
> **Вывод**: 2 0 3

> **Вопрос**: Как написать алгоритм для подобного *range-query*?

> - Можно всякий раз осуществлять полный *inorder*-обход, что дорого. А можно не полный, а в определённом диапазоне. 

Оказывается, что в стандарте есть контейнер `std::set`, который организован как поисковое дерево. И в интерфейсе этого контейнера присутствуют нужные нам методы `upper_bound` и `lower_bound`.

```cpp
template <typename C, typename T>
  int range_query(const C& s, T fst, T snd) {
  using itt = typename C::iterator;
  itt start = s.lower_bound(fst);   /* first not less then fst
    * возвращает "ссылку" на первый объект из дерева,
    * значение которого больше или равно fst -type C */

  itt fin = s.upper_bound(snd);     /* first greater then snd 
   * возвращает "ссылку" на первый объект из дерева,
   * значение которого строго больше snd -type C */

  return mydistance(s, start, fin); /* std::distance для set
   * возвращает кол-во объектов между start и fin. */
  
  /* Мы можем вызвать сам std::distance, но для этого
   * у нас должен быть перегружен operator<, а про 
   * перегрузку операторов мы ещё не говорили. 
   * Но мы можем без проблем определить глобальный метод,
   * считающий нужный нам distance.*/ 
}
```

[Проектирование поискового дерева](https://youtu.be/duDyVgMFyug?t=374)

Спроектируем же наше поисковое дерево, которое решит нам эту задачу не хуже `std::set`.

```cpp
namespace Trees {
  template <typename KeyT, typename Comp>
  class SearchTree {

    // тип внутреннего узла, определение которого пока не важно
    struct Node;

    using iterator = Node *;  // итератор положение внутри дерева
    Node *top_;  // указатель на вершину

   public: // селекторы
    iterator lower_bound(KeyT key) const;
    iterator upper_bound(KeyT key) const;
    int distance(iterator fst, iterator snd) const;
    
   public: // модификаторы
    void insert(KeyT key);
    ...
  }
  ...
}
```
Можно заметить, как красиво модификаторы доступа отделяют ф-ции по характеру. Да, поля доступа внутри определения класса можно переоткрывать сколько угодно раз. 

Подумаем об инвариантах хорошего поискового дерева. Можно сразу смекнуть, что условие поисковости - это не единственный инвариант, который нам хотелось бы организовать при проектировании. Ведь вот такое дерево:
 &nbsp;| &nbsp;
:-:|:-:
<img src="imgs/bad_tree.png"> | оно конечно поисковое, но в худшем случае отсортированный по возрастанию список тоже является поисковым деревом. Искать в нём элементы не эффективно. И делать в них ranged-queries тоже.

Нам нужна балансировка. Популярны два варианта балансировки